<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>6. 虚拟机字节码执行引擎</title>
    <link href="/2020/10/23/JVM/6.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <url>/2020/10/23/JVM/6.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>　　Java虚拟机规范中制定了虚拟机字节码执行引擎的<strong>概念模型</strong>，这个概念模型成为各种虚拟机执行引擎的<strong>统一外观（Facade）</strong>。从外观上看来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理的是字节码解析的等效过程，输出的是执行结果。   </p><h2 id="2-运行时栈帧结构"><a href="#2-运行时栈帧结构" class="headerlink" title="2. 运行时栈帧结构"></a>2. 运行时栈帧结构</h2><p>　　<strong>栈帧（Stack Frame）</strong>是用于支持虚拟机进行方法调用和方法执行的数据结构，他是虚拟机运行时数据区中的<strong>虚拟机栈</strong>的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程都对应一个栈帧在虚拟机中<strong>从入栈到出栈</strong>的过程。<br>　　在编译程序代码时，栈帧中需要多大的局部变量表，多深的操作数栈都已经<em>完全确定了</em>，并写入到<em>方法表的Code属性</em>中，因此一个栈帧需要分配多少内存不会受到程序程序运行期间变量数据的影响，而仅仅取决于具体的虚拟机实现。<br>　　一个线程中的方法调用链可能很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有<em>位于栈顶的栈帧才是有效的</em>，称为<strong>当前栈帧</strong>（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧操作。            </p><h3 id="（1）-局部变量表"><a href="#（1）-局部变量表" class="headerlink" title="（1） 局部变量表"></a>（1） 局部变量表</h3><p>　　<em>局部变量表</em>是一组变量值存储空间，用于<em>存放方法参数和方法内部定义的局部变量</em>。在Java程序编译为Class文件时，就在方法Code属性的max_locals数据项中确定了该方法需要分配的局部变量表的最大容量。<br>　　局部变量表的容量以<strong>变量槽</strong>（Variable Slot）为最小单位。虚拟机允许Slot长度可以随着处理器等的不同而发生变化，所以没有明确指出每个Slot应该占有的内存大小，只是规定每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。这八种数据类型都可以使用32位或更小的物理内存来存放。<br>　　对于64位的数据类型，虚拟机会以<em>高位对齐</em>方式为其分配两个连续的Slot空间。Java中明确的64位类型只有long和double（reference可能是32位或64位）。由于局部变量表建立在线程堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。<br>　　虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，索引范围从0到局部变量表最大的Slot数量。如果访问32位的变量，索引n代表了使用第n个Slot，如果是64位的数据类型变量，说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的Slot，不允许用任何方式单独访问其中的一个。<br>　　<strong>this指针的JVM原理</strong>：方法执行时，虚拟机是使用局部变量表完成<strong>参数值到参数变量列表的传递过程的</strong>。如果执行的是<strong>实例方法（非static的方法）</strong>，那么局部变量表中第0位索引默认传递的是<strong>方法所属对象实例的引用</strong>，在方法中通过关键字<strong>“this”</strong>来访问此隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的Slot。<br>　　为了尽量节省栈帧空间，局部变量表中的Slot是<strong>可重用的</strong>。<br>　　另外，局部变量不像前面介绍的类变量那样存在“准备阶段”。我们已经知道类变量有两次赋值的过程，首先是准备阶段赋与<em>系统初始值</em>；另一次在初始化阶段，赋予程序员定义的初始值。这样即使在初始化阶段程序员没有给类变量赋值也没关系，因为类变量仍然有一个确定的初始值。但是局部变量不同，定义而不赋初始值是不能使用的。   </p><h3 id="（2）-操作数栈"><a href="#（2）-操作数栈" class="headerlink" title="（2） 操作数栈"></a>（2） 操作数栈</h3><p>　　操作数栈<em>（Operand Stack）</em>也常称为操作数栈，它是一个后进先出栈。和局部变量表相同，操作数栈的最大深度也在编译时写入到Code属性的max_stacks数据项中，操作数栈的每个元素可以是<em>任意的Java数据类型</em>，包括long和double。32位数据占1个栈容量，64位则占两个栈容量。<br>　　当一个方法刚刚开始执行，其操作数栈是空的。在方法执行过程中，各种字节码指令向操作数栈中写入、提取内容，也就是出入栈操作。操作数栈中的元素类型必须和字节码指令的序列严格匹配。    </p><h3 id="（3）动态连接"><a href="#（3）动态连接" class="headerlink" title="（3）动态连接"></a>（3）动态连接</h3><p>　　每个栈帧都包含一个指向<em>运行时常量池</em>中该栈帧所属方法的引用，用于支持方法调用过程中的<em>动态连接</em>。我们已经知道Class文件常量池中有大量符号引用，<em>字节码中的方法调用指令就以常量池中指向方法的符号引用为参数</em>。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为<em>静态解析</em>。另外一部分则在每一次运行期间转化为直接引用，这部分称为动态连接。</p><h3 id="（4）方法返回地址"><a href="#（4）方法返回地址" class="headerlink" title="（4）方法返回地址"></a>（4）方法返回地址</h3><p>　　一个方法开始执行后，只有两种方式退出这个方法。第一种方法是执行引擎遇到任意一个<em>方法返回的字节码指令</em>，这个时候可能有返回值传递给上层方法调用者；这种退出方法称为<strong>正常完成出口</strong>。<br>　　另一种退出方式是在方法执行过程中出现了<em>异常</em>，并且该异常没有在方法体内得到处理，只要在本方法的异常表中没有搜索到匹配的<em>异常处理器</em>，就会导致方法退出，这种退出方法的方式称为<strong>异常完成出口</strong>，这种方法不会给上层调用者产生任何返回值。<br>　　无论用何种退出方式，方法退出后，程序都要返回到方法被调用的位置才能继续执行。方法返回时可能要在栈帧中保存一些信息，用于帮助恢复其上层方法的执行状态。方法正常退出时，调用者的PC计数器的值可以作为返回地址。<br>　　方法退出时相当于当前栈帧出栈。</p><h2 id="3-方法调用"><a href="#3-方法调用" class="headerlink" title="3. 方法调用"></a>3. 方法调用</h2><p>　　方法调用阶段的唯一任务就是<strong>确定要调用哪个方法</strong>，即明确调用方法的版本，暂时还不涉及方法内部的具体运行过程。Class文件编译过程中不包含传统编译器的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是直接引用（在实际运行时内存布局中的入口地址）。这个特性给Java带来了强大的动态扩展能力，但也使方法调用过程复杂起来，需要在类加载期间甚至运行期间才能确定目标方法的直接引用。     </p><h3 id="（1）-解析"><a href="#（1）-解析" class="headerlink" title="（1） 解析"></a>（1） 解析</h3><p>　　所有的方法调用中的目标方法在Class文件中都只是常量池中的符号引用，在类加载解析阶段会将其中的一部分符号引用转化为直接引用（静态解析）。静态解析成立的条件是方法在程序真正运行前就有一个可确定的调用版本，并且方法的调用版本在运行期间是不可变的。即就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法调用称为<strong>解析</strong>。<br>　　Java中符合上述的“编译期间可知，运行期间不可变”要求的方法主要包括<em>静态方法</em>和<em>私有方法</em>两大类，他们都不可能被重写，故而适合在类加载阶段解析。Java虚拟机中提供了五条方法调用字节码指令：<em>invokestatic</em>：调用静态方法；<em>invokespecial</em>：调用实例构造器init方法、私有方法和父类；<em>invokevirtual</em>：调用所有的虚方法；<em>invokeinterface</em>：调用接口方法，会在运行时再确定一个实现此接口的对象；<em>invokedynamic</em>：在动态运行时解析出调用点限定符所引用的方法，然后再执行该方法。    　　只要是能被invokedynamic指令和invokespecial指令调用方法，都可以在解析阶段唯一确定调用版本，符合该条件的静态方法、私有方法、实例构造器、父类方法，他们在类加载时就会把符号引用解析为该方法的直接引用。这些方法可以称为<em>非虚方法</em>，其他方法称为<em>虚方法</em>（除去final）。由于没有重载版本，在多态选择结果肯定是唯一的，Java规范中明确指明了final方法是非虚方法。<br>　　解析调用是一个静态过程，在编译期间完全确定，在类装载的解析阶段就会<em>把涉及的符号引用全部转变为直接引用</em>。而<em>分派调用</em>则可能是静态的或者动态的。    </p><h3 id="（2）-分派"><a href="#（2）-分派" class="headerlink" title="（2） 分派"></a>（2） 分派</h3><h4 id="1-静态分派"><a href="#1-静态分派" class="headerlink" title="1. 静态分派"></a>1. 静态分派</h4><pre><code>package .../**方法静态分派演示*@author zzm*/public class StaticDispath&#123;    static abstruct class Human&#123;    &#125;    static class Man extends Human&#123;    &#125;    static class Women extends Human&#123;    &#125;    public void sayHello(Human guy)&#123;        System.out.println(“Hello, guy!”);    &#125;    public void sayHello(Man guy)&#123;        System.out.println(“Hello, gentleman!”);    &#125;    public void sayHello(Woman guy)&#123;        System.out.println(“Hello, lady!”);    &#125;    public static void main(String[ ] args)&#123;        Human man = new Man( );        Human woman = new Woman( );        StaticDispatch sr = new StaticDispath( );        sr.sayHello(man);        sr.sayHello(woman);    &#125;&#125;     </code></pre><p>　　运行结果：<br>    Hello, guy!<br>    Hello, guy!<br>　　我们将上面代码中的Human称为变量的<strong>静态类型</strong>，或者变量的<strong>外观类型</strong>，后面的Man则为变量的<strong>实际类型</strong>，二者的区别在于静态类型的变化仅仅在使用时发生，变量本身静态类型不变，最终的静态类型是编译期可知的；而实际类型变化的结果在运行期间才能确定，编译器在编译程序时候不知道一个对象的实际类型是什么。例如：　　　</p><pre><code>//实际类型变化Human man = new Man( );man = new Woman( );//静态类型变化sr.sayHello((Man) man);se.sayHello((Woman) man);     </code></pre><p>　　举例代码中刻意定义了两个静态类型相同而实际类型不同的变量，但编译器在重载时是通过参数的<strong>静态类型</strong>作为判定依据的。静态类型编译期可知，因此在编译阶段，编译器就根据参数静态类型觉得使用哪个重载版本，故而选择了sr.sayHello(Human)为调用目标，并将该方法的符号引用写到main方法里的两条invokevirtua指令的参数中。<br>　　<em>所有依赖静态类型定位方法执行版本的分派动作称为静态分派</em>。静态分派的典型应用是<em>方法重载</em>。由于发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机执行的。另外，编译器可以确定方法的重载版本，很多情况下这版本并不唯一，往往只能确定一个“更加合适”的版本，这就是重载方法匹配的优先级。举个例子（为节省篇幅，采用模糊的表示）：　　　</p><pre><code>public class Overload &#123;    public static void sayHello(Object arg) &#123;        syso(“hello Object”);    &#125;    public static void sayHello(int arg) &#123;        syso(“hello int”);    &#125;    public static void sayHello(long arg) &#123;        syso(“hello long”);    &#125;    //接下来的参数依次为：Character arg, char arg, char... arg, Serializabel arg,     //函数形式和上面相同；    public static void main( String [ ] args)&#123;        sayHello(‘a’);    &#125;&#125;    </code></pre><p>　　运行后输出hello char，如果注释掉sayHello(char arg)方法，输出变为：hello int，即将字符a转化为数字97；再注释掉int参数方法，得到：hello long，即字符a转换为int后进一步转换为长整数long。实际上这种转换可以发生多次，按照char，int，long，float，double顺序。不会匹配到byte和short类型的重载，因为是char到他们的转型是不安全的。注释掉long参数方法，输出为：hello Charater，这时候发生的是<em>自动装箱</em>。再注释掉该方法，得到运行结果为：hello Serializable（序列化），因为java.long.Serialicable是java.lang.Charater类的一个接口，装箱后找不到装箱类，但找到了装箱类实现了的<em>接口类型</em>，所以又发生了一次自动转型，Character类可以<em>安全转型为它实现的接口类或父类</em>。接口类型的重载方法优先级是一样的，比如Character实现了另一个接口java.lang.Comparabel<Charater>，如果同时出现了参数为Serializable和Comparable<Character>类型的重载，会提示类型模糊，拒绝编译。必须显示指定类型如：sayHello( Comparable<Character>’a’)才能编译通过。<br>　　如果此时再注释掉序列化参数方法，输出结果为：hello Object，因为char装箱为父类后，如果有多个父类，那么将在继承关系中从下往上搜寻，<em>越上层的父类优先级越低</em>。将Object参数方法也注释掉，输出为：hello char …。可见<em>变长参数的重载优先级最低</em>，此时字符‘a’被当作一个数组元素。<br>　　上述例子演示的是<em>编译期间选择静态分派目标的过程</em>，该过程是Java实现方法重载的本质。    </p><h4 id="2-动态分派"><a href="#2-动态分派" class="headerlink" title="2. 动态分派"></a>2. 动态分派</h4><p>　　动态分派和多态的另一个体现：<strong>重写</strong>（Override）有密切关联。前面提到的静态分派是根据参数的静态类型作为判定重载方法版本依据的，而动态分派是通过实际类型进行判断的。<br>　　由于invokevirtual指令执行的第一步就是<em>在运行期间确定接收者的实际类型</em>，所以两次调用该指令把常量池中的类方法符号引用解析到不同的直接引用上，这就是重写的本质。        </p><h3 id="3-单分派与多分派"><a href="#3-单分派与多分派" class="headerlink" title="3. 单分派与多分派"></a>3. 单分派与多分派</h3><p>　　方法的接收者与方法的参数统称为方法的<strong>宗量</strong>，根据分派基于多少宗量，可以把分派划分为单分派和多分派。目前Java语言的静态分派属于多分派类型，动态分派属于单分派。<br>　　目前的Java语言通过内置的动态语言（如JavaScript）执行引擎的方式满足动态性的需求。但是Java虚拟机层面并非如此，在JDK1.7中就已经提供了对动态语言的支持了，JDK1.7中新增的invokedunamic指令也成为了最复杂的一条方法调用的字节码指令。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>三、虚拟机执行子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 关系模型介绍</title>
    <link href="/2020/10/22/Database%20System%20Concepts/1.%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/10/22/Database%20System%20Concepts/1.%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="关系模型介绍"><a href="#关系模型介绍" class="headerlink" title="关系模型介绍"></a>关系模型介绍</h1><h2 id="1-关系数据库结构"><a href="#1-关系数据库结构" class="headerlink" title="1. 关系数据库结构"></a>1. 关系数据库结构</h2><p>　　关系数据库由<em>表（table）</em>的集合构成，每个表名字是唯一的。 表中的一行代表一组值之间的一种联系。<em>关系（relation）</em>用来指代表，而<em>元组（tuple）</em>这个术语对应表中的行，<em>属性（attribute）</em>对应表中的列。我们用<em>关系实例（relation Instance）</em>表示一个表的特定实例，即这个表在某个时刻的一个“快照”。对于每个属性，都存在一个允许取值的集合，称为该属性的<em>域（domain）</em>。如果域中的元素可以看作不可再分的单元，则称域是<em>原子的（atomic）</em>。<em>空（null）值</em>是一个特殊的值，表示未知或不存在，应尽量避免使用空值。  </p><h2 id="数据库模式"><a href="#数据库模式" class="headerlink" title="数据库模式"></a>数据库模式</h2><p>　　<em>数据库模式（database schema）</em>是指数据库的逻辑设计，而前面说的<em>数据库实例</em>是给定时刻数据库中数据的一个快照。<em>关系模式（relation schema）</em>概念对应程序设计语言中的数据类型，更易懂的说法，就是一个表的组成布局结构模式。</p><h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><p>　　码是一种能区分给定关系中不同元组的方法（通俗地说，区分一个表中不同行的方法，以后都使用术语代替通俗的说法），也就是说一个元组的属性值必须能<em>唯一区分</em>这个元组。<br>　　<em>超码（superkey）</em>：一个或者多个属性列的集合，这些属性的组合可以让我们唯一识别一个元组。如果K是一个超码，那么K的任意超集也是超码。  　　　　　<br>　　<em>候选码（candidate key）</em>：最小的超码，即任意真子集都不能成为超码的超码。<br>　　<em>主码（primary key）</em>：被数据库设计者选中的候选码，用来在一个关系中区分唯一的元组。码是整个关系的性质，而不是单个元组的性质。主码的选择必须慎重，选择那些值从不变化的属性。<br>　　<em>外码（foreign key）</em>：一个关系模式（r1）可能在它的某个属性中包含另一个关系模式（r2）的主码。这个属性在r1上被称为<em>参照r2的外码</em>。r1称作外码依赖　　<br>　　<em>参照关系</em>，r2称作外码的被参照关系。如果在参照关系中，任意元组在特定属性上的取值必然等于被参照关系中某个元组在特定属性上的取值，这种情况就符　<br>　　<em>参照完整性约束（referentional integrity constraint）</em>的要求。  </p><h2 id="模式图"><a href="#模式图" class="headerlink" title="模式图"></a>模式图</h2><p>　　一个含有主码和外码依赖的数据库模式可以用<em>模式图</em>来表示。每个关系由矩形表示，关系名在矩形上方，矩形内列出属性。主码属性用下划线标注。外码依赖从参照关系的外码属性到被参照关系的主码属性之间的箭头表示。</p><h2 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h2><p>　　<em>查询语言</em>是用户用来从数据库中请求信息的语言。分为过程化的和非过程化的。简单的说，过程化语言要求用户一步一步指导系统，自己需要的数据的查询过程，SQL就属于这种形式。而非过程化语言，用户只要描述一下自己要的信息，不用给出具体的获得过程。<br>##关系运算<br>    从单个关系或多个关系中进行运算，运算结果总是单个关系。<br>    <em>连接运算</em>：把分别来自两个关系的元组对合并成单个元组。<br>    <em>笛卡尔积</em>：从两个关系中合并元组，结果包含来自两个关系的所有元组对。<br>　　<em>自然连接</em>：对于分别来自关系r1和r2中的两个元组来说，如果他们在某个属性上的取值相同，那么他们就是匹配的。进行自然连接后，所有这样匹配的元组对都会在连接结果中出现。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>一、关系型数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. SQL</title>
    <link href="/2020/10/22/Database%20System%20Concepts/2.%20SQL/"/>
    <url>/2020/10/22/Database%20System%20Concepts/2.%20SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="1-SQL查询语言概览"><a href="#1-SQL查询语言概览" class="headerlink" title="1. SQL查询语言概览"></a>1. SQL查询语言概览</h2><p>　　SQL（结构化查询语言），最早成为Sequel，有以下几个部分：<br>　　<em>数据定义语言（DDL）</em>、<em>数据操纵语言（DML）</em>、<em>完整性</em>、<em>视图定义</em>、<em>事务控制</em>、<em>嵌入式SQL和动态SQL</em>、<em>授权</em>。</p><h2 id="2-SQL数据定义"><a href="#2-SQL数据定义" class="headerlink" title="2. SQL数据定义"></a>2. SQL数据定义</h2><p>　　数据库中的关系集合必须由DDL指定给系统。</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>　　SQL支持多种固有类型，包括：<br>　　<em>char（n）</em>：固定长度字符串，n为用户指定的长度，也可以用全称character。<br>　　<em>varchar（n）</em>：可变长度字符串，用户指定最大长度n，全称character varying。<br>　　<em>int</em>：整型。<br>　　<em>smallint</em>：小整数类型。<br>　　<em>numeric（p，d）</em>：定点数，精度用户指定。该数有p位数字（一个符号位），其中d位在小数点右边。比如numeric（3，1）可以精确存储44.5。<br>　　<em>real，double precision</em>：浮点数、双精度浮点数。<br>　　<em>float（n）</em>：精度至少为n的浮点数。<br>　　char型存储定长字符串，如果char（10）类型存储了字符串“AVI”，那么其后会追加7个空格。而如果使用varchar（10）则不会。比较char值时如果长短不同，会追加空格使等长。建议始终使用varchar。  </p><h3 id="基本模式定义"><a href="#基本模式定义" class="headerlink" title="基本模式定义"></a>基本模式定义</h3><p>　　用<strong>create table</strong>定义SQL关系，如： </p><pre><code>**CREAT TABLE** department    (dept_name **varchar**(20),building **varchar**(15),   budget **numeric**(12,2),   **PRIMARY KEY**(dept_name));//这是完整性约束   </code></pre><p>　　SQL语句不分大小写，因此SELECT语句和select是相同的，写成Select也没有关系，许多SQL开发人员喜欢对所有SQL关键字大写，对所有列和表名使用小写，使代码更容易阅读调试。<br>　　CREATE命令以分号结束，支持许多不同的完整性约束。例如<em>primary key（Aj1，Aj2，Aj3… … ）</em>声明表示属性Aj1… …构成关系的主码，主码属性必须<em>非空且唯一</em>。<em>foreign key (Ak1, Ak2, … …) references</em>声明表示关系中任意元组在A… …属性上的取值必须对应于关系s中某元组在主码属性上的取值。<em>not null</em>约束表明该属性不允许空值。<br>　　SQL禁止任何破坏完整性约束的数据库更新。一个新建的关系最初是空的。可以用<strong>insert</strong>命令将数据加载到关系中。例如：<br>    <em>INSERT INTO</em> instructor<br>        <em>VALUES</em>（111，‘Smith’，‘History’）；<br>　　同样的，使用<strong>delete from</strong>命令从关系中删除元组；如果要从SQL数据库中去掉一个关系，使用<strong>drop table</strong>命令，从数据库中删除关于被去掉关系的所有信息。命令drop table r；是比delete from r；更强的语句，delete删除表中的所有元组，但保留关系。drop则连同关系r的模式一并删除。<br>    我们使用<strong>alter table</strong>命令为已有关系增加<strong>属性</strong>。关系中所有元组在新属性上的取值被设置为null。alter table格式为：<br>    <strong>alter table</strong> r <strong>add</strong> A D；<br>    r是先有关系的名字；A是待添加属性的名字，D是待添加属性的域。同样的格式，我们可以用<br>    <strong>alter table</strong> r <strong>drop</strong> A；<br>    从r中去掉现有属性A。很多数据库系统不支持这个操作。</p><h2 id="3-SQL查询的基本结构"><a href="#3-SQL查询的基本结构" class="headerlink" title="3. SQL查询的基本结构"></a>3. SQL查询的基本结构</h2><pre><code>SQL查询基本结构由三个子句构成：**SELECT，FROM和WHERE**。   </code></pre><h3 id="单关系查询"><a href="#单关系查询" class="headerlink" title="单关系查询"></a>单关系查询</h3><pre><code>查询输入是在from子句中列出的关系，在这些关系上进行where和select子句中指定的运算，产生一个关系作为结果。  假定某个大学数据库维护这样一个关系instructor，表示所有任课教师的信息，其中有名字、薪资等属性。简单的查询所有教师的名字：  **SELECT** name      **FROM** instructor；     </code></pre><p>　　执行上述语句可以得到所有教师名字的属性表。此查询允许重复，因为有的教师可以同名，并且去重是一件非常麻烦的工作。如果要强行删除重复，可以在SELECT后加入关键字<strong>DISTINCT</strong>。SQL也允许在相同位置使用关键词<strong>ALL</strong>来显式指明不去重。<br>    select子句还允许带有+、-、<em>、/ 运算符的算数表达式，运算对象当然是常数或元组的属性，如<br>    select ID，salary</em>1.1<br>    from instructor；<br>    查询得到的salary是原来的1.1倍。但是这只是对查询结果的影响，不会对instructor关系有任何改变。<br>    where允许我们只选出那些在from子句的结果关系中满足特定谓词的元组，且允许在where中使用<strong>or、and、not</strong>。   </p><h3 id="多关系查询"><a href="#多关系查询" class="headerlink" title="多关系查询"></a>多关系查询</h3><pre><code>我们给出大学数据库的模式图示例——通过前面的介绍你已经知道了模式图的表示方法的话，你应该明白模式图表示的数据库结构。  现在假设要找出所有教师的姓名以及他们所在系的名称和系所在建筑的名称，这样的查询可以写作：   **SELECT** name, instructor.dept_name,building     **FROM** instructor, department**WHERE** instructor.dept_name = department.dept_name;      </code></pre><p>　　注意dept_name既出现在instructor中也出现在department中。关系名被用作<strong>前缀</strong>来说明我们使用的是哪个属性。查询所代表运算应该这样理解：先FROM，然后WHERE，最后是SELECT。理解步骤如下：<br>    1）为FROM子句中列出的关系产生<em>笛卡尔积</em>。<br>    2）在1的结果上应用WHERE子句中指定的谓词。<br>    3）对于2）中的每个元组，输出SELECT中指定的属性。   </p><h2 id="4-附加的基本运算"><a href="#4-附加的基本运算" class="headerlink" title="4. 附加的基本运算"></a>4. 附加的基本运算</h2><h3 id="（1）更名运算"><a href="#（1）更名运算" class="headerlink" title="（1）更名运算"></a>（1）更名运算</h3><p>　　SQL提供了一个重命名结果关系中属性的方法，即使用<strong>as</strong>子句。更名运算在很多情况下特别有用。假定如下查询：找出满足下列条件的教师姓名，他们的工资至少比Biology系某个教师工资高。这个查询可以写作：<br>    <strong>SELECT DISTINCT</strong> T.name<br>    <strong>FROM</strong> instructor <strong>AS</strong> T, instructor <strong>AS</strong> S<br>    <strong>WHERE</strong> T.salary &gt; S.salary <strong>AND</strong> S.dept_name = ‘Biology’;<br>    在上述查询中，T和S可以被认为是关系instructor的两个别名。正如我们将要看到的那样，我们举例的这个查询可以直接用SQL表达。   </p><h3 id="（2）字符串运算"><a href="#（2）字符串运算" class="headerlink" title="（2）字符串运算"></a>（2）字符串运算</h3><p>　　SQL用一对单引号表示字符串，如果单引号自身也是字符串的一部分，就用两个单引号表示，如‘It’’s right’。         对于字符串运算，可以用<em>upper（）</em>、<em>lower（）</em>大小写转换、用<em>LIKE</em>实现模式匹配等。     </p><h3 id="（3）SELECT子句中的属性说明"><a href="#（3）SELECT子句中的属性说明" class="headerlink" title="（3）SELECT子句中的属性说明"></a>（3）SELECT子句中的属性说明</h3><pre><code>星号可以用在SELECT子句中表示“所有的属性”，比如“ SELECT instructor. * ”。    </code></pre><h3 id="（4）排列元组次序"><a href="#（4）排列元组次序" class="headerlink" title="（4）排列元组次序"></a>（4）排列元组次序</h3><p>　　SQL提供了<strong>ORDER BY</strong>子句让查询结果按照排列顺序显示，默认使用升序，要说明顺序我们可以用<strong>DESC</strong>表示降序，<strong>ASC</strong>表示升序，如“<strong>ORDER BY</strong> salary <strong>DESC</strong>, name <strong>asc</strong>; ”。     </p><h3 id="（5）where子句谓词"><a href="#（5）where子句谓词" class="headerlink" title="（5）where子句谓词"></a>（5）where子句谓词</h3><p>　　SQL提供了<strong>BETWEEN</strong>比较运算符，使用如“SELECT salary… … BETWEEN 90000 AND 100000”，同样可以使用NOT BETWEEN运算符。  </p><h2 id="5-集合运算"><a href="#5-集合运算" class="headerlink" title="5. 集合运算"></a>5. 集合运算</h2><h2 id="6-空值"><a href="#6-空值" class="headerlink" title="6. 空值"></a>6. 空值</h2><h2 id="7-聚集函数"><a href="#7-聚集函数" class="headerlink" title="7. 聚集函数"></a>7. 聚集函数</h2><h2 id="8-嵌套子查询"><a href="#8-嵌套子查询" class="headerlink" title="8. 嵌套子查询"></a>8. 嵌套子查询</h2><h2 id="9-数据库修改"><a href="#9-数据库修改" class="headerlink" title="9. 数据库修改"></a>9. 数据库修改</h2>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>一、关系型数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. JVM大纲</title>
    <link href="/2020/10/21/JVM/1.%20JVM%E5%A4%A7%E7%BA%B2/"/>
    <url>/2020/10/21/JVM/1.%20JVM%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<p> <img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/Xmind.png"></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>一、JVM大纲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>5. 虚拟机类加载机制</title>
    <link href="/2020/10/21/JVM/5.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/10/21/JVM/5.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>　　<em>虚拟机类加载机制概念</em>：虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。<br>　　上一章节介绍了Class文件存储格式的细节，在Class文件中描述的各种信息，最终都要加载到虚拟机之后才能运行和使用。虚拟机如何加载这些Class文件，Class文件内容进入虚拟机后产生何种变化？这是本章讨论的内容。  </p><h2 id="2-何时开始类加载过程"><a href="#2-何时开始类加载过程" class="headerlink" title="2. 何时开始类加载过程"></a>2. 何时开始类加载过程</h2><p>　　类从被加载到虚拟机内存中开始，到完全卸载出内存为止，整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）</strong>7个阶段，其中验证、准备、解析三个部分统称为<strong>连接（Linking）</strong>。<br>　　加载、验证、准备、初始化、卸载这5个阶段顺序是确定的。而解析阶段可能在初始化后开始。另外这7个阶段通常是交叉混合式进行的。<br>　　什么时候开始第一个阶段：加载？Java虚拟机对此没有明确规定，但规定了以下情况必须立即对类进行初始化，那么加载、验证、准备自然需要在此之前进行了：<br>　　1） 遇到new等四条字节码指令时。常见代码场景：new一个关键字实例化对象时；读取一个类的静态字段时；调用一个类静态方法时。<br>　　2） 用java.lang.reflect包方法对类进行反射调用时；<br>　　3） 初始化一个类时，先初始化其父类初始化（如果父类未初始化）；<br>　　4）虚拟机启动时，先初始化包含main的主类；  </p><h2 id="3-类加载过程"><a href="#3-类加载过程" class="headerlink" title="3. 类加载过程"></a>3. 类加载过程</h2><h3 id="（1）加载"><a href="#（1）加载" class="headerlink" title="（1）加载"></a>（1）加载</h3><p>　　加载阶段，虚拟机完成以下事情：<br>　　1） 通过一个类的全限定名称获取此类的二进制字节流。（这个过程是开发人员可控性最强的，由类加载器完成）<br>　　2） 将此字节流代表的静态存储结构转化为方法区的<em>运行时数据结构</em>。<br>　　3） 内存中生成一个代表该类的<em>java.lang.Class对象</em>，作为方法区这个类的数据访问入口。<br>　　加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，具体的存储格式虚拟机可自行定义。然后在内存中实例化<em>java.lang.Class</em>类对象，作为访问方法区中类型数据的外部接口。     </p><h3 id="（2）验证"><a href="#（2）验证" class="headerlink" title="（2）验证"></a>（2）验证</h3><p>　　验证是连接阶段的第一步，目的是<em>确保Class文件字节流中的信息符合当前的虚拟机的要求</em>，并且不会危害虚拟机自身的安全。<br>　　前面提到过Class文件不一定通过Java源码编译而来，可以由任何途径产生，甚至直接用文本编辑器编写。虚拟机如果不检查输入的字节流，盲目信任的话又可能载入有害字节流导致崩溃。验证阶段是否严谨直接决定了虚拟机能否承受恶意代码的攻击。<br>　　验证阶段包括文件格式验证、元数据验证、字节码验证。   </p><h3 id="（3）准备"><a href="#（3）准备" class="headerlink" title="（3）准备"></a>（3）准备</h3><p>　　准备阶段是正式<em>为类变量分配内存并设置类变量初始值</em>的阶段，这些变量所使用的内存都将在方法区中进行分配。这里进行内存分配的<em>仅包括类变量</em>（被static修饰的变量），不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆。其次这里的初始值通常情况下是数据类型的零值。举例：<br>　　public static int value = 123；<br>　　变量value在准备过程后初始值为0而不是123，因为尚未执行任何Java方法，将value赋值为123的操作在初始化阶段才会执行。但如果是：<br>　　public static final int value = 123；<br>　　那么准备阶段value就会初始化为123。  </p><h3 id="（4）解析"><a href="#（4）解析" class="headerlink" title="（4）解析"></a>（4）解析</h3><p>　　解析阶段通常是虚拟机将<em>常量池内的符号引用</em>替换为<em>直接引用</em>的过程；<br>　　<em>符号引用：</em>以一组符号描述引用的目标。符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。<br>　　<em>直接引用（Direct References：</em>直接引用可以是直接指向目标的指针、相对偏移量或者一个能间接定位目标的<em>句柄</em>，如果有了直接引用，那么引用的目标必定已经存在于内存中。直接引用和虚拟机实现的<em>内存布局</em>相关，相同的符号引用，在不同虚拟机上翻译出来的直接引用一般不同。<br>　　对同一个符号进行多次解析的情况并不少见。虚拟机实现可以对第一次解析的结果进行<em>缓存</em>，即在运行时常量池中记录对应的直接引用，并把常量标示为已解析状态。如果一个符号引用以前被成功解析过，那么后续引用解析请求就一直成功；如果第一次解析失败了，那么其他指令对该符号的解析请求也应该收到相同的异常。<br>　　对于用于动态语言支持的invokedynamic指令，上述规则不成立。因为该指令的目的是为了提供<em>动态语言支持</em>，指必须等到程序实际执行到该指令时，解析动作才能执行。相对的，其余可触发解析指令都是“静态的”，在刚刚完成加载阶段，还没有开始执行代码时就进行解析。<br>　　<em>1. 类或接口的解析</em><br>　　现在假设要把一个从未进行过解析的符号引用N解析为一个类或接口C的直接引用，当前代码所属的类为D。<br>    1. 如果要解析的类或接口C不是数组类型，虚拟机把代表N的全限定名传递给D的<em>类加载器</em>去加载类C。如果加载过程出现异常，解析过程宣告失败。<br>    2. 如果C是一个数组类型，并且数组的元素是对象类型，则按照第一点的规则加载数据元素类型。<br>    3. 如果前驱过程没有出现任何异常，那么C在虚拟机中实际上已经成为有效的类或接口了。但是解析完成之前需要进行<em>符号引用验证</em>，确认D是否具备对C的访问权限。如果不具备访问权限，抛出java.lang.IllegalAccessError异常。<br>    <em>2. 字段解析</em><br>    <em>3. 类方法解析</em><br>    <em>4.接口方法解析</em></p><h3 id="（5）初始化"><a href="#（5）初始化" class="headerlink" title="（5）初始化"></a>（5）初始化</h3><p>　　类初始化阶段是类加载过程的最后一步，从这一步才开始真正执行类中定义的Java程序代码（字节码）。      我们说过在准备阶段，变量就已经赋值过一次系统要求的初始值；而在初始化阶段则是根据程序员通过代码制定的计划去初始化类变量和其他资源。初始化是执行类构造器clinit（）方法的过程。   </p><h2 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h2><p>　　虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到虚拟机外部实现，以便于让程序自己决定如何获取需要的类，实现这个动作的代码模块称为“<em>类加载器</em>”。</p><h3 id="（1）类和类加载器"><a href="#（1）类和类加载器" class="headerlink" title="（1）类和类加载器"></a>（1）类和类加载器</h3><p>　　对于一个类，需要由加载它的类加载器和该类本身一同确立其在Java虚拟机中的唯一性。也就是说要判定两个类“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不能判定为“相等”。<br>　　这里“相等”的判定，包括代表类的Class对象的equals（）方法、is Instance（）方法的返回结果、使用instanceof关键字做对象所属关系的判定情况。如果不注意类加载器的影响，某些判定情况下会产生迷惑性的结果。    </p><h3 id="（2）双亲委派模型"><a href="#（2）双亲委派模型" class="headerlink" title="（2）双亲委派模型"></a>（2）双亲委派模型</h3><p>　　从Java开发人员的角度看，类加载器可以划分为：<br>　　<strong>启动类加载器</strong>（Bootstrap ClassLoader）：负责将放在<JAVA_HOME>\lib中的可被虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。<br>　　<strong>扩展类加载器</strong>（Extension ClassLoader）：可以被开发者直接使用，负责加载<JAVA_HOME>\lib\ext目录中的类库。<br>　　<strong>应用程序类加载器</strong>（Application ClassLoader）：也称为系统类加载器。负责加载用户类路径（ClassPath）上指定的类库。<br>　　<strong>自定义类加载器</strong>：如果有必要，可以加入自定义的类加载器。<br>　　<strong>双亲委派模型</strong>（Parents Delegation Model）：要求除了顶层的启动类加载器之外，其余的类加载器都要有自己的父类加载器。类加载器的父子关系一般不会以继承实现，而是以组合关系复用父加载器的代码。<br>　　<strong>工作过程</strong>：如果一个类加载器收到了加载类的请求，首先不会尝试自行加载该类，而是将请求<strong>委派</strong>给父类加载器去执行。每一个层次的加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己不能完成这个加载请求时，子加载器才会尝试自己加载。<br>　　<strong>优点</strong>：双亲委派模型的一个显而易见的好处是Java类随着类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，无论哪个类加载器要求加载该类，最终都会交给最顶端的启动类加载器加载（启动能加载器可以自己加载这个类），因此Object类在程序中的各种类加载环境中都是同一个类。如果没有使用双亲委派模型，各个类自行加载的话，如果用户自己编写了一个同名的类并放在程序的ClassPath中，那系统中将会出现多个同名的但是实际不同的Objet类，应用程序将一片混乱！</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>三、虚拟机执行子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>4. 类文件结构</title>
    <link href="/2020/10/21/JVM/4.%20%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/21/JVM/4.%20%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p><img src="/img">     </p><h2 id="1-Java无关性的基石"><a href="#1-Java无关性的基石" class="headerlink" title="1. Java无关性的基石"></a>1. Java无关性的基石</h2><p>　　Java刚诞生时著名的宣传口号是<em>“一次编写，到处运行”</em>，“与平台无关”的理想最终实现在操作系统应用层上：Sun公司以及其他虚拟机发布商提供了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种<em>平台无关的字节码</em>。各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——<em>字节码</em>，ByteCode，是构成平台无关性的基石。另外，语言无关性正在越来越被开发者重视。时至今日许多机构已经发展出了在Java语言之外的可以在Java虚拟机上运行的语言，如Clojure、Jython、JRuby等。<br>　　实现语言无关性的基础仍然是<em>虚拟机和字节码存储格式</em>。这里的字节码存储格式指的是Java虚拟机不和任何语言绑定，只和<em>”Class文件“</em>这种特定的<em>二进制文件格式</em>关联。基于安全性的考虑，Java虚拟机规范要求了在Class文件中使用许多强制性的语法和结构化约束（下节讨论），但是<em>任何一门功能性语言都可以表示为一个可被Java虚拟机接受的有效Class文件</em>。例如使用Java编译器可以将Java语言翻译成存储字节码的Class文件，用JRuby等其他语言的编译器也可以把程序代码编译成Class文件，虚拟机不关心Class文件的来源是何种语言，只关注Class文件的安全格式检查和执行。     </p><h2 id="2-Class类文件结构"><a href="#2-Class类文件结构" class="headerlink" title="2. Class类文件结构"></a>2. Class类文件结构</h2><p>　　Class文件是一组以8位字节为基础单位的<em>二进制流</em>，各个数据项目严格按照顺序紧凑排列在Class文件中，中间没有任何分隔符，各个细节都是被严格限定的，哪个字节是什么含义，长度多少，先后顺序如何都不允许改变。Java虚拟机规范的规定要求Class文件以一种类似于C语言体系结构的伪结构存储数据，这种伪结构只有两种数据类型：<em>无符号数和表</em>。<br>无符号数属于基本数据类型，用U1、U2、U4、U8分别代表1、2、4、8个字节的无符号数。<br>　　表是由其他无符号数或表作为数据项构成的复合数据类型，所有表在Class文件中以“_info”结尾。用于描述有层次关系的复合结构数据。  </p><h3 id="（1）魔数与Class版本"><a href="#（1）魔数与Class版本" class="headerlink" title="（1）魔数与Class版本"></a>（1）魔数与Class版本</h3><p>　　每个Class文件开头四个字节固定为<em>魔数</em>（Magic Number），唯一作用是<em>确定这个文件是否能被一个Java虚拟机接受</em>。Class文件的魔数值为：0xCAFEBABE（咖啡宝贝？），似乎预示着Java商标的出现。<br>　　紧接着魔数的是Class文件的版本号：5、6字节是次版本号，7、8字节是主版本号。高版本的JDK 可能兼容低版本的Class文件，但虚拟机必须拒绝执行超过其版本号的Class文件。   </p><h3 id="（2）常量池"><a href="#（2）常量池" class="headerlink" title="（2）常量池"></a>（2）常量池</h3><p>　　紧接着主次版本号之后的是<em>常量池入口</em>。<em>常量池</em>可以理解为Class文件之中的资源仓库，是Class文件中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，还是Class中第一个出现的表类型数据项目。<br>　　常量池入口放置一项<em>U2类型</em>的数据，代表常量池<em>容量计数值</em>，索引范围从1而不是0开始。    </p><p>　　常量池中主要存放两大类常量：<em>字面量Literal</em>和<em>符号引用Symbolic References</em>。常量池符号引用的具体结构查阅参考书目P167，主要包含下面三类常量：<br>　　1） 类和接口的全限定名（Fully Qualified Name）；<br>　　2） 字段的名称和描述符；<br>　　3） 方法的名称和描述符。<br>　　Java代码在经过javac编译时没有“连接”步骤，而是在虚拟机加载Class文件时进行<em>动态链接</em>。所谓动态链接的含义是，由于在Class文件中不保存各个方法和字段的最终内存布局信息，因此这些字段和方法的符号引用必须经过运行期间的转换，获得真正的内存入口地址，从而才能被虚拟机使用。虚拟机运行时，需要从常量池获得对应的符号引用，再于类创建时或运行时解析、翻译到具体的内存地址中。可见<em>动态链接</em>的特性和Java的平台无关性联系紧密。   </p><h3 id="（3）访问标志"><a href="#（3）访问标志" class="headerlink" title="（3）访问标志*"></a>（3）访问标志*</h3><p>　　常量池结束后紧接着的两个字节代表<em>访问标志（access_flags）</em>，用于<em>识别类或者接口层次的访问信息</em>，如这个Class是类还是接口，是否定义为public等。具体标志位对应不同的含义，可通过参考书目查阅。</p><h3 id="（4）类索引、父索引与接口索引集合"><a href="#（4）类索引、父索引与接口索引集合" class="headerlink" title="（4）类索引、父索引与接口索引集合*"></a>（4）类索引、父索引与接口索引集合*</h3><p>内容鸽掉啦～</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>三、虚拟机执行子系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>3. 垃圾收集器与内存分配策略</title>
    <link href="/2020/10/21/JVM/3.%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <url>/2020/10/21/JVM/3.%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>　　<em>垃圾收集器</em>（Garbage Collection，GC）历史比Java久远。经过半个多世纪的发展，目前内存动态分配与回收技术已经相当成熟。理解GC和内存分配，有助于我们排查各种内存溢出、内存泄漏问题，攻克垃圾收集称为系统达到更高并发的瓶颈。回顾主题二中的介绍，我们知道程序计数器、Java虚拟机栈、本地方法栈这三区域是<em>线程私有的</em>，和线程共存亡；这几个区域的内存分配和回收都具有确定性，因为每一个栈帧中分配多少内存，大体可以认为在类结构确定下来时就是已知的，在这几个区域不必考虑回收问题。但是Java堆和方法区不同，一个接口中的多个实现类需要的内存可能不同，一个方法多个分支的内存也不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收都是<em>动态的</em>，GC关注的就是这部分内存。  </p><h2 id="2-对象是否死亡的判断"><a href="#2-对象是否死亡的判断" class="headerlink" title="2. 对象是否死亡的判断"></a>2. 对象是否死亡的判断</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>　　引用计数法<em>Reference Count</em>简单来说就是给对象中添加引用计数器，每当引用一次，计数器加一，引用失效时就减一。实现简单，判定效率高，但存在的致命问题是无法解决对象间相互引用！也就是因为这个原因，主流Java虚拟机中没有选用此方法。  </p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>　　可达性分析（<em>Reachability Analysis</em>）被主流的商用程序语言应用。基本思路是通过一系列称为“<em>GC Roots</em>”的对象作为起始点，从这些结点开始向下搜索，搜索走过的路径称为<em>引用链（Reference Chain）</em>，当一个对象到GC Roots没有任何引用链相连时（图论中所谓“不可达”），证明此对象是不可用的。如图所示的object4、5、6被认为是可回收的对象。<br><img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.jpg"></p><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>　　上述的两种死亡判断算法都与引用有关。但是如果我们要描述这样的对象：在内存相对空闲时，能保留在内存中；但是在内存紧张时，这类对象可以被GC回收。我们根据引用的强弱程度对引用的概念进行了扩充，从强到弱依次为：强引用、软引用、弱引用、虚引用。  </p><h3 id="对象的自救"><a href="#对象的自救" class="headerlink" title="对象的自救"></a>对象的自救</h3><p>　　即使在可达性分析中判定为可回收的对象，也不是“非死不可”的。可达性分析判定为可回收时，该对象处于“缓行”阶段，要真正宣判“死刑”，至少要经历两次<em>标记</em>过程。如果对象在可达性分析中判定为不可达，那么将会被第一次标记并进行一次筛选，筛选条件时次对象是否有必要执行finalize（）方法。如果当前对象未覆盖finalize方法，或finalize方法已经被虚拟机调用过了，虚拟机将这两种情况都视为“没有必要执行”。<br>　　如果对象被判定为有必要执行finalize方法，那么它基本被宣告“死刑”了。但是此时的对象仍然有逃脱的机会。当被判定有必要执行finalize时，对象会被放在一个叫<em>F- Queue</em>的队列中，并在稍后由一个虚拟机建立的、低优先级的<em>Finalizer线程</em>去触发这个方法。所谓的触发是指虚拟机触发这个方法，但不保证会等待它执行结束。处在这个状态中的“犯人”们等待GC对F- Queue中的对象打上第二次小规模的标记。此时如果他们足够幸运，有机会改判“无期徒刑”：当Finalize方法执行缓慢或者死循环，很可能导致F- Queue队列中其他对象处于永久等待！或者也可以选择“改过自新”拯救自己——重新与引用链上的任何一个对象建立关联，那么在第二次标记时将被移出即将回收的集合。如果运气很差又“执迷不悟”的话，那它就真的被回收了。<br>　　现在建议各位忘记finalize（）方法的存在——即时上述的例子足够生动地描述了这个过程。该方法运行代价高昂，不确定性大。它所能做的所有工作，使用try-finali或其他方法都能做的更好。  </p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>　　标记-清除（Mark- Sweep）算法正如其名，先标记出所有要回收的对象，完成后统一回收所有带标记的对象。作为最基础的收集算法，标记-清除算法存在以下问题：首先是效率问题，两个过程的效率都不高；其次是产生大量内存碎片——还记得吗，我们之前讨论内存分配时说到具体的分配方法和GC采用的垃圾收集算法有关，如果虚拟机采用标记-清除法的垃圾收集器，那么分配Java堆内存时采用<em>空闲列表</em>的方法。  </p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>　　复制（Coping）算法将可用内存容量分为两块，每次使用其中的一块。当这一块内存使用完了，就将存活的对象全部复制到另一块，再把使用过的这一半全部清理掉。实现简单，运行高效。<br>　　现在的商业虚拟机使用该方法回收<em>新生代</em>的对象。新生代98%对象都是朝生夕死的，所以不需要按照1:1比例划分空间，而是分为一块较大的<em>Eden空间</em>和两块较小的<em>Survivor空间</em>，回收时将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，再清理掉Eden和刚才使用过的Survivor空间。HotSpot默认的Eden和Survivor空间大小是8:1，也就是说只有10%空间被“浪费”。当然我们没法保证每次回收都只有不到10%对象存活，当Survivor空间不足时，需要依赖<em>老年代</em>进行<strong>分配担保</strong>（<em>Handle Promotion</em>）。<br>　　分配担保：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活的对象时，这些对象将直接分配进入老年代。  </p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>　　根据老年代的特点，标记-整理（Mark- Compact）算法应运而生。标记过程和标记-清除算法相同，但后续不是进行清理而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。  </p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>　　当前的商业虚拟机都采用分代收集（Generational Collection）算法，将Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代每次垃圾收集都有大量对象被清除，就采用复制算法；而老年代对象存活率高，使用标记-清除或标记-整理算法回收。  </p><h2 id="4-HotSpot算法实现"><a href="#4-HotSpot算法实现" class="headerlink" title="4. HotSpot算法实现"></a>4. HotSpot算法实现</h2><h3 id="枚举GC-Roots"><a href="#枚举GC-Roots" class="headerlink" title="枚举GC Roots"></a>枚举GC Roots</h3><p>　　以可达性分析中从GC Roots节点找引用链为例，可以作为GC Roots的节点主要在全局性的引用与执行上下文中。现在很多应用仅方法区就很大，如果逐个检查其中的引用，必然带来大的内存消耗和时间。<br>　　另外讨论<em>GC停顿</em>——可达性分析工作必须在一个确保一致性的快照中进行，这里的一致性指在整个可达性分析期间，整个执行系统看起来就像被冻结在某个瞬间了一样，也就是说在分析过程中对象引用关系不能处在变化中，否则分析结果的准确性就没有保证。这点是导致GC进行时必须停顿所有Java线程（Sun将这件事称为“Stop The World”）的一个重要原因。<br>　　由于目前的主流Java虚拟机都使用了<em>准确式GC</em>，很好解决了第一个找引用的问题。当执行系统停顿下来后，不需要一个不漏的检查完所有执行上下文和全局变量的引用位置，虚拟机有办法直接得知哪些地方存放对象引用。在HotSpot实现中就是使用一组称为OopMap的数据结构实现这个目的。类加载完成时HotSpot就把对象内什么偏移量处是何种类型的数据算出来，在JIT编译过程中也会在指定位置记录下栈和寄存器中哪些位置是引用。这样GC在扫描时可以直接得知这些信息。  </p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>　　在OopMap协助下HotSpot可以快速完成GC Roots枚举，为了避免OopMap内容变化指令太多而带来的存储空间成本太高的问题，实际上HotSpot也没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，这些位置称为<em>安全点（Safe point）</em>，即程序执行时，并非在所有地方都能停下来GC，只有到达安全点时才能暂停。对于安全点另一个考虑的问题是，如何在GC发生时让所有的线程都跑到最近的安全点上再停顿下来。现在广泛采用的是<em>主动式中断</em>方式，当GC需要开始Stop The World时，不对线程操作，而是设置一个标志，线程轮询这个标志，发现中断标志为真就自己中断挂起来，轮询标志的设置当然是和安全点重合的。  </p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>　　如果在发生GC时，有的线程处于Sleep和Block的状态，那么它肯定不能相应JVM的中断请求，也不能自己查询标志。这种情况需要<em>安全区域</em>解决。<br>　　安全区域指在一段代码片段之中，引用关系不会发生变化。此区域中任意地方开始GC都是安全的，也可以理解为其中每一个地方都是Safe point。线程执行到Safe Region中的代码时，高高标识自己进入了“安全区”，这样在JVM要发起GC时就不用管标示为安全的线程了。线程离开安全区域时要检查系统是否已经完成了GC Roots枚举，完成了就继续执行，否则要等待直到收到离开Safe Region的信号为止。    </p><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h2><p>　　收集算法是垃圾收集的方法论，垃圾收集器是具体的实现。JVM规范中对垃圾收集器的实现没有规定，因此不同厂商提供的垃圾收集器可能有很大差别。这个主题的目的是我们会选择对具体应用最合适的收集器。</p><h3 id="（1）Serial收集器"><a href="#（1）Serial收集器" class="headerlink" title="（1）Serial收集器"></a>（1）Serial收集器</h3><p>　　最基本的收集器就是serial收集器了，是一个<em>单线程</em>的收集器，单线程的意思是它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，<em>必须暂停其他所有的工作线程直到他收集结束</em>。这对用户来说是难以接受的——你的计算机每工作一小时就暂停响应5分钟，这对很多电脑游戏爱好者来说比洗澡时停水还让人难受。<br>　　但实际上到现在为止Serial收集器依靠它的简单和高效依然被运行在Client模式下的JVM设置为默认的新生代收集器。用户桌面场景中，由于分配给JVM的内存一般不会很大，停顿时间可以控制在一百毫秒内。所以Serial对于运行在Client模式下的虚拟机来说是个很好的选择。  </p><h3 id="（2）ParNew收集器"><a href="#（2）ParNew收集器" class="headerlink" title="（2）ParNew收集器"></a>（2）ParNew收集器</h3><p>　　Serial收集器的多线程版本。除了多线程收集外，其他与Serial收集器没有太大创新之处。但它确实许多运行在<em>Server模式</em>下的虚拟机中首选的新生代收集器（我们提到过许多虚拟机实现对新生代和老年代采用不同的收集器），主要原因是除了Serial外只有ParNew收集器可以和CMS收集器配合工作（CMS稍后介绍，他是HotSpot虚拟机中第一款真正意义上的并发收集器，第一次实现了垃圾收集线程和用户线程基本上同时工作）。</p><h3 id="（3）Parallel-Scavenge收集器"><a href="#（3）Parallel-Scavenge收集器" class="headerlink" title="（3）Parallel Scavenge收集器"></a>（3）Parallel Scavenge收集器</h3><p>　　新生代收集器，同样使用复制算法且是并行的多线程处理器。特点是它的关注点和其他收集器不同——相比于其他收集器关注尽量缩短GC发生时用户线程的停顿时间，Parallel Scavenge 收集器强调达到一个可控制的<em>吞吐量</em>（Throughput）。假定<em>运行用户代码时间</em>为 T ，则吞吐量=T/T+垃圾收集时间）。高吞吐量可以高效利用CPU时间，尽快完成运算任务，适合运行在后台而不需要过多交互的任务。  </p><h3 id="（4）Serial-Old收集器"><a href="#（4）Serial-Old收集器" class="headerlink" title="（4）Serial Old收集器"></a>（4）Serial Old收集器</h3><p>　　Serial收集器的老年版本，是一个使用<em>标记-整理</em>算法的单线程收集器，这个收集器的主要意义也是给在Client模式下的虚拟机使用。  </p><h3 id="（5）Parallel-Old收集器"><a href="#（5）Parallel-Old收集器" class="headerlink" title="（5）Parallel Old收集器"></a>（5）Parallel Old收集器</h3><p>　　Parallel Scavenge收集器的老年版本，使用<em>多线程</em>和<em>标记-整理</em>算法。在Parallel Old收集器出现后，“吞吐量优先”收集器终于有了名副其实的应用组合，在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><h3 id="（6）CMS收集器"><a href="#（6）CMS收集器" class="headerlink" title="（6）CMS收集器"></a>（6）CMS收集器</h3><p>　　CMS（Concurrent Mark Sweep）收集器是一种以<em>获取最短回收停顿时间</em>为目标的收集器。由于现在很大一部分的Java应用集中在互联网站服务器山，这一类应用尤其重视访问速度，CMS非常符合这类网站的需求。<br>　　从名字上就可以看出CMS是基于标记-清除算法实现的，运作过程分为四个步骤：<br>　　<em>初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）、并发清除（CMS concurrent sweep）。  *<br>　　其中，初始标记、重新标记这两步骤仍然需要“Stop The World”，初始标记仅仅是标记一下GC Roots关联到的对象，速度很快；并发标记阶段是进行GC Roots Tracing过程，而重新标记阶段是为了修正并发标记期间因为用户程序继续运作而导致的标记变动，这一部分时间也很短。也正是由于过程中耗时最长的并发标记和并发清除过程中，收集器都可以和用户线程*同时工作</em>，因此总体上CMS收集器的内存回收过程是和用户线程一起并发执行的。<br><strong>CMS的缺点：</strong><br>　　1. 对CPU资源敏感。并发期间由于占用CPU资源导致应用程序变慢。<br>　　2. 无法处理浮动垃圾（Floating Garbage）。由于CMS并发清理阶段用户线程还在继续工作，自然还会有新的垃圾产生，这部分垃圾出现在标记过程之后，CMS无法在本次回收过程中清理他们，只能等待下一次GC。这部分垃圾称为<em>“浮动垃圾”</em>。<br>　　3.CMS基于标记-清除算法实现决定了收集结束时有大量内存碎片产生，从而给大对象的内存分配带来麻烦，无法为大对象找到合适的内存，不得不提前触发一次Full GC。      </p><h3 id="（7）G1收集器"><a href="#（7）G1收集器" class="headerlink" title="（7）G1收集器"></a>（7）G1收集器</h3><p>　　G1收集器（Garbage-First）是一款面向服务端应用的垃圾收集器。具备以下特点：<br>    1. 并行与并发：充分利用多核、多CPU的优势，缩短Stop The World时间。<br>    2. 分代收集：同其他的收集器相同，分代概念在G1收集器中得以保留。虽然G1可以不和其他的GC配合就独立管理整个GC堆，但能采用不同方式处理新对象和多次熬过GC的旧对象。<br>    3. 空间整合：整体上来看G1是基于“标记-整理”算法的收集器。从局部（两个Region）来看是采用“复制”算法的收集器。这意味着在GC期间不会产生内存碎片，GC后，可以提供相对规整的内存。这种特性有利于长期运行程序。<br>    4. 可预测停顿：除了追求低停顿外，G1 还能建立可预测的停顿时间模型，可以让用户指明在未来M毫秒时间段内，消耗在GC过程的时间不超过N毫秒。这几乎已经是实时Java（RTSJ）的垃圾收集器特征了。<br>　　<em>原理</em>：G1之前的其他收集器都将收集范围都是整个新生代或老年代，而G1将整个Java堆划分为多个大小相等、不需要连续的<em>独立区域</em>集合（Region），虽然保留了新生代和老年代的概念，但是他们已经不是物理隔离的了。G1之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪每个Region里面的垃圾堆积的<em>价值</em>大小，这个“垃圾的价值”由回收所能获得的空间大小和回收所需时间的经验值来衡量。G1跟踪这个价值并在后台维护一个<em>优先列表</em>，每次根据允许的收集时间，优先回收价值最大的Region，这也是G1名称Garbage First的来由。<br>　　也许有人注意到了，把Java堆分成若干Region后，GC过程就真的可以以Region为单位进行了吗？换句话说，一个Region不可能是孤立的，一个对象分配在某个Region中，并不能限定它只能和本Region中的其他对象之间发生引用，而是可以和Java堆中任何对象发生引用关系。难道把人类划分为几大家族，家族之间就不允许联姻了吗？正因如此，在可达性分析时岂不是还要扫描整个Java堆才能保证其准确性？<br>　　值得注意的是，这个问题不是只出现在G1中，只是G1中更明显。实际上，无论是G1收集器中Region之间的对象引用，还是其他收集器中的新生代和老年代之间的引用，虚拟机都是使用<em>Remembered Set</em>避免全堆扫描的。简单来说，每个Region中都有对应的Remembered Set，当程序对Reference类型的数据写操作时，会暂时中断写操作（通过一个Write Barri），检查Reference引用的对象是否处于不同Region之间（分代中就是检查老年代对象是否引用了新生代对象），如果是就通过Card Table把相关记录信息记录到被引用对象所属Region的Remembered Set中。内存回收时，在GC根节点枚举范围中加入Remembered Set可保证不对全堆扫描也不会遗漏。<br>　　忽略对Remembered Set的操作，G1收集器的运作大致分为以下步骤：<br>　　初始标记、并发标记、最终标记、筛选回收。      相信很多读者会发现有几个步骤和CMS相似。<em>初始标记</em>阶段仅仅标记一下GC Roots能直接关联的对象，修改Next Top at Mark Start，（NTMS）的值。让下一阶段用户程序并发执行时，能在正确可用的Region中创建新对象。初始标记需要时停，但时间很短。<em>并发标记</em>阶段开始可达性分析，需要时间长，但可以和用户线程并发执行。<em>最终标记</em>阶段为了修正并发标记期间因用户线程而产生变动的记录，虚拟机将变动记录在Remembered Set Logs中，并在此阶段将其并入Remembered Set。这个阶段需要停顿线程，但是可以多线程并行这个过程。最后<em>筛选回收</em>阶段对各个Region的“价值”进行排序，并根据用户期望的GC停顿时间制定回收计划。  </p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p>　　GC日志是人为制定的规则，容易理解，只需要参考资料即可，可查阅《深入理解Java虚拟机》（周志明著，第二版，机械工业出版社）P89。  </p><h2 id="6-内存分配策略"><a href="#6-内存分配策略" class="headerlink" title="6.内存分配策略"></a>6.内存分配策略</h2><p>　　Java体系中的自动内存管理可以归结为自动化解决了两个问题：<em>给对象分配内存和回收分配给对象的内存</em>。关于回收我们已经详细介绍过了，接下来看看给对象分配内存时发生了什么。<br>　　我们说过现在的商业虚拟机都采用复制算法回收新生代。下面的讨论基于使用Serial/Serial Old收集器。<br>　　对象的内存分配就是堆上分配（也可能栈上分配），对象主要分配在新生代的<em>Eden区</em>上。如果启用了<em>本地线程缓冲，TLAB</em>，将按照线程在TLAB上分配（我们在介绍对象的创建过程时，讨论到对象创建的并发安全性时介绍过TLAB）。分配的规则不是确定的，而是要看当前使用的哪种垃圾回收组合，以及虚拟机相关参数的设置。  </p><h3 id="（1）对象优先在Eden分配"><a href="#（1）对象优先在Eden分配" class="headerlink" title="（1）对象优先在Eden分配"></a>（1）对象优先在Eden分配</h3><p>　　大多数情况下对象优先在Eden分配。当Eden区空间不足，将发起一次<em>Minor GC</em>（新生代垃圾回收）。<br>　　虚拟机提供了收集器日志参数，告诉虚拟机在发生GC时打印内存回收日志，并在进程退出时输出当前的内存各区域分配情况。新生代中Eden区和Survivor区的大小比例也可以通过参数设置。  </p><h3 id="（2）大对象直接进入老年代"><a href="#（2）大对象直接进入老年代" class="headerlink" title="（2）大对象直接进入老年代"></a>（2）大对象直接进入老年代</h3><p>　　典型的大对象是很长的字符串和数组，大对象对虚拟机的内存分配是个实打实的坏消息，尤其是朝生夕死的大对象是更坏的消息。如果把分配一个大对象内存比做服务一个麻烦的顾客，那么一个朝生夕死的大对象就好像是不仅为这个顾客提供了麻烦的服务，最后还要花费更大的精力全额退款。经常出现大对象，内存容易不得不提前触发GC来安置他们。<br>    虚拟机提供了一个参数，只要需要分配内存的对象大小大于这个参数，这个对象就会<em>直接进入老年代</em>。  </p><h3 id="（3）长期存活的对象进入老年代"><a href="#（3）长期存活的对象进入老年代" class="headerlink" title="（3）长期存活的对象进入老年代"></a>（3）长期存活的对象进入老年代</h3><p>　　虚拟机给每个对象定义了一个<em>对象年龄计数器</em>。如果对象在Eden出生且第一次Minor GC后仍然存活且能被Survivor容纳的话，根据复制算法，它将进入Survivor中，并且将计数器年龄+1。每熬过一次Minor GC，年龄加一。年龄达到阈值（默认15）时，对象晋升到老年代中。  </p><h3 id="（4）动态对象年龄判定"><a href="#（4）动态对象年龄判定" class="headerlink" title="（4）动态对象年龄判定"></a>（4）动态对象年龄判定</h3><p>　　并不是只有年龄计数器达到阈值才可以进入老年代。<em>如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代</em>。  </p><h3 id="（5）空间分配担保"><a href="#（5）空间分配担保" class="headerlink" title="（5）空间分配担保"></a>（5）空间分配担保</h3><p>　　我们在复制算法中同样提到过，survivor空间不足时要依靠老年代进行<em>分配担保</em>，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代还有足够的容纳空间。<br>　　在发生Minor GC之前虚拟机先检查老年代最大可用空间是否大于<em>新生代所有对象总空间</em>。如果是，那么本次Minor GC可以认为是安全的。否则查看虚拟机参数设置值是否允许担保失败。如果允许检查老年代剩余空间是否大于<em>历次晋升到老年代对象的平均大小</em>，如果大于，将尝试一次Minor GC，尽管冒着风险。如果小于或者虚拟机设置为不允许担保失败，那么改为进行一次<em>Full GC</em>。      所谓的“冒着风险”是指如果本次进入老年代的存活对象大小激增，超出了历次平均的经验值，依然导致<em>担保失败（Handle Promotion Failure）</em>，只好在失败后重新发起Full GC，这样就绕了一大圈。即便如此一般也将虚拟机设置为允许担保失败，可以避免过于频繁的Full GC。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>二、内存自动管理机制</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. Java内存区域溢出与内存溢出异常</title>
    <link href="/2020/10/21/JVM/2.%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/10/21/JVM/2.%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h2><p>###　1. 程序计数器<br>　　程序计数器可以看成是<strong>当前线程所执行字节码的行号指示器</strong>。虚拟机的概念模型中，字节码解释器就是通过改变计数器的值来选取下一条需要执行的字节码指令。分支、跳转、循环等基础功能都要依赖计数器完成。    　　<br>　　我们都应该知道Java虚拟机的多线程实际上是通过多个线程的轮流切换并分配处理器时间来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，因此为了线程切换后能恢复到正常的位置，每个线程都需要有一个<em>独立的程序计数器</em>，互不影响，独立存储，我们称类似程序计数器这样的内存为“线程私有的内存”。<br>    如果一个线程正在执行一个Java方法，该程序计数器存储的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法则计数器值为空。  </p><h3 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h3><p>　　Java虚拟机栈同样是线程私有的，生命周期和线程相同。<br>　　虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个<em>栈帧</em>（Stack frame）存储局部变量表、操作数栈、动态链接等信息方法的调用到执行完毕的过程对应了一个栈帧在虚拟机中入栈和出栈的过程。<br>　　所谓的<em>局部变量表</em>存放了编译期间可知的各种基本数据类型、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。<br>　　其中64位长度的long、double类型数据占用两个局部变量空间（Slot），其余数据类型只占用一个。局部变量表需要的内存空间在编译期间就完成分配，进入一个方法时，该方法在栈帧中分配多大的局部变量空间是完全确定的，运行期间，局部变量表大小不变。<br>　　Java虚拟机规范中对虚拟机栈规定了两种异常：<strong>StackOverflowError</strong>异常：线程请求的栈深度大于虚拟机栈允许的深度；<strong>OutOfMemoryError</strong>异常：当虚拟机栈进行动态扩展而无法申请到足够的内存时抛出。  </p><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>　　虚拟机栈为虚拟机执行Java方法服务，而本地方法栈（Native Method Stack）则为虚拟机使用到的Native方法服务。由于在虚拟机规范中没有强制规定其格式，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接把这两个栈合二为一。和虚拟机栈一样，本地方法栈也抛出相同的两个异常：StackOverflowError和OutOfMemoryError。  </p><h3 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h3><p>　　对于大多数应用，<em>Java堆（Java heap）</em>是Java虚拟机所管理内存中最大的一块。Java堆在虚拟机启动时创建，是被所有线程<em>共享</em>的一块内存区域。此内存区域唯一目的是<strong>存放内存对象实例</strong>。<br>　　Java堆是<strong>垃圾收集器</strong>管理的主要区域，很多时候被称为<strong>GC堆</strong>，即 <strong>Garbage Collected Heap</strong>。<br>　　Java堆的细分：从内存回收角度，由于现在的收集器基本采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为新生代和老年代。<br>　　从内存分配角度，被线程所共享的Java堆中还可以分出多个线程私有的<em>分配缓冲区</em>。不过划分与存放内容无关，划分的目的是为了更好的回收内存，或者更快地分配内存。<br>　　Java堆可以处于物理上不限续的内存空间中，只要逻辑上连续即可。大多数实现为大小可扩展的，如果在堆中没有完成实例分配且堆也无法扩展时，将抛出<em>OutOfMemoryError</em>异常。  </p><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>　　和Java堆一样，方法区<em>Method Area</em>和Java堆一样是各个线程<em>共享</em>的内存区域，用于存储已经被虚拟机加载过的类信息、常量、静态变量即时编译后的代码等数据。别名“非堆<em>Non- Heap</em>”，目的是和Java堆区分。当方法区内存不够用时，抛出OutOfMemoryError异常。  </p><h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><p>　　运行时常量池（<em>Runtime Constant Pool</em>）是方法区的一部分。class文件有一项信息是<em>常量池</em>，用于存放编译期生成的各种字面量和符号引用，在类加载后，这部分内容进入方法区的运行时常量池中存放。但运行时常量池相对于class文件常量池的一个明显特征是<strong>具备动态性</strong>，Java不要求常量只能在编译期间产生，也就是说进入运行时常量池中的内容不一定全部要来自于class文件中常量池的预置，运行期间可以有新的常量进入运行时常量池中。这种特性用的比较多的是String类的intern方法。<br>　　由于是方法区的一部分，运行时常量池自然被方法区限制，在内存不够用时抛出OutOfMemoryError异常。  </p><h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3><p>　　直接内存不属于Java虚拟机规范中定义的内存区域。这部分内存被频繁使用，且可能导致OutOgMemoryError出现。如果服务器管理员在配置虚拟机参数时忽略直接内存，使得整个内存区域总和大于物理内存限制，从而导致动态扩展时发生OutOfMemoryError异常。  </p><h2 id="2-HotSpot虚拟机对象创建、布局和访问"><a href="#2-HotSpot虚拟机对象创建、布局和访问" class="headerlink" title="2. HotSpot虚拟机对象创建、布局和访问"></a>2. HotSpot虚拟机对象创建、布局和访问</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>　　<strong>检查参数</strong>：虚拟机遇到new指令时先<strong>检查这个指令的参数</strong>，是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否被加载、解析、初始化过。如果没有则必须先执行相应的类加载过程。<br>　　<strong>分配内存</strong>：之后虚拟机为新生对象<strong>分配内存</strong>，该过程等同于把一块确定大小的内存从Java堆中划分出来。两种分配方式分别为：<strong>指针碰撞</strong>和<strong>空闲列表</strong>。<br>　　<em>指针碰撞</em>：如果Java堆内存绝对规整，所有用过的内存放在一边，空闲的放在另一边，中间分界点用一个指针标示。那么在分配内存时只需要把指针向空闲方向移动一段和对象大小相等的距离。<br>　　<em>空闲列表</em>：Java堆内存不规整，已使用的内存和空闲内存交错，此时虚拟机维护一个记录空闲内存块的表，记录哪些内存块可用，分配时找一块足够大的空间划分给对象，并更新列表上的记录。<br>　　具体采用何种方式由Java堆规整程度决定，而Java堆规整程度又由虚拟机<strong>垃圾收集器</strong>所采用的<strong>垃圾收集算法</strong>决定：典型地，采用<strong>标记-整理</strong>算法，指针碰撞适用；采用<strong>标记-清除</strong>算法，空闲列表适用。<br>　　注意内存分配的一个问题，那就是对象创建是一个非常频繁的行为。并发情况下即便是移动一个指针的位置，该操作也是<strong>线程不安全的</strong>。解决方案有两种：对内存分配动作<strong>同步处理</strong>或将内存分配动作按照线程划分在不同空间中进行，即为每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>，即Thread Local Allocation Buffer，<strong>TLAB</strong>。哪个线程要分配内存就在该线程的TLA B上分配，只有TLAB用完而分配新的TLAB时才需要进行同步锁定操作。虚拟机是否使用TALB可以由参数设定。<br>　　<strong>初始化</strong>：虚拟机将需要分配到的内存空间都初始化为0值。这一操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序可以访问到这些字段的数据类型对应的零值。<br>　　<strong>必要设置</strong>：设置对象的哈希码、GC分代年龄等信息，存放在对象头中。<br>　　<strong>init方法</strong>： 执行完上述方法后从虚拟机角度看新的对象已经诞生了，但从Java程序视角来看对象创建才刚刚开始——init方法还没有执行，所有字段都还为0。执行init后一个真正可用的对象才创建出来。<br>![](/img/posts/Java虚拟机整理/对象创建过程.png</p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p>　　HotSpot虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>Header、<strong>实例数据</strong>Instance Data、<strong>对齐填充</strong>Padding。<br>　　<em>对象头</em>：包含两部分信息：用于存储对象自身的<strong>运行时数据</strong>和<strong>类型指针</strong>。对象需要存储的运行时数据很多，如哈希码、GC分代年龄、锁状态标志、偏向时间戳等。类型指针则是对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。并非所有虚拟机实现都必须在对象数据上保留类型指针，即查找对象的元数据信息不一定要经过对象本身。如果对象是一个Java数组，那么对线头中还必须有一块用于记录数组长度的数据，因为虚拟机从数组的元数据中不能确定其大小（但是可以通过普通Java对象的元数据确定Java对象的大小）。<br>　　<em>实例数据</em>：存储对象<em>真正存储的有效信息</em>，即在程序代码中定义的各种类型的字段内容。这部分的存储顺序受到<em>虚拟机分配策略参数</em>和<em>字段在Java源码中定义顺序</em>的影响。<br>　　<em>对齐填充</em>：不必要且没有特别含义，作为占位符存在。  </p><h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p>　　Java操作具体的堆上的对象需要通过栈上的<em>reference</em>（指针）数据。reference类型在Java虚拟机规范中只规定了一个对象引用，并没有定义这个引用应该通过何种方式去定位和访问堆中具体对象的位置，所以对象的访问方式取决于<em>虚拟机的具体实现</em>。目前主流访问方式有使用<em>句柄</em>和<em>直接指针</em>两种。<br>　　<em>句柄</em>访问方式的实现：Java堆中划分一块内存作为句柄池，reference对象中存储的是对象的句柄地址，而在句柄中包含了对象实例数据与类型数据各自的地址信息。<br>　　<img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.jpg"><br>　　<em>直接指针</em>访问实现：Java堆对象布局中必须考虑如何放置访问类型数据的相关信息，而reference中直接存储对象地址。<br>　　<img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg"><br>　　优缺点：句柄方式的最大优点就是reference中存储稳定的句柄地址，在对象被移动时只改变实例数据指针，reference本身不需要修改；直接指针方式优点是访问速度快，节省了一次指针访问的开销。 </p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>二、内存自动管理机制</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机整理</title>
    <link href="/2020/10/19/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/"/>
    <url>/2020/10/19/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p> <img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/Xmind.png"></p><h1 id="一、Java历史"><a href="#一、Java历史" class="headerlink" title="一、Java历史"></a>一、Java历史</h1><h1 id="二、Java内存区域与内存溢出异常"><a href="#二、Java内存区域与内存溢出异常" class="headerlink" title="二、Java内存区域与内存溢出异常"></a>二、Java内存区域与内存溢出异常</h1><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h2><ol><li><p>程序计数器<br> 程序计数器可以看成是<strong>当前线程所执行字节码的行号指示器</strong>。虚拟机的概念模型中，字节码解释器就是通过改变计数器的值来选取下一条需要执行的字节码指令。分支、跳转、循环等基础功能都要依赖计数器完成。<br> 我们都应该知道Java虚拟机的多线程实际上是通过多个线程的轮流切换并分配处理器时间来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，因此为了线程切换后能恢复到正常的位置，每个线程都需要有一个<em>独立的程序计数器</em>，互不影响，独立存储，我们称类似程序计数器这样的内存为“线程私有的内存”。<br> 如果一个线程正在执行一个Java方法，该程序计数器存储的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法则计数器值为空。  </p></li><li><p>Java虚拟机栈<br> Java虚拟机栈同样是线程私有的，生命周期和线程相同。<br> 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个<em>栈帧</em>（Stack frame）存储局部变量表、操作数栈、动态链接等信息方法的调用到执行完毕的过程对应了一个栈帧在虚拟机中入栈和出栈的过程。<br> 所谓的<em>局部变量表</em>存放了编译期间可知的各种基本数据类型、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。<br> 其中64位长度的long、double类型数据占用两个局部变量空间（Slot），其余数据类型只占用一个。局部变量表需要的内存空间在编译期间就完成分配，进入一个方法时，该方法在栈帧中分配多大的局部变量空间是完全确定的，运行期间，局部变量表大小不变。<br> Java虚拟机规范中对虚拟机栈规定了两种异常：<strong>StackOverflowError</strong>异常：线程请求的栈深度大于虚拟机栈允许的深度；<strong>OutOfMemoryError</strong>异常：当虚拟机栈进行动态扩展而无法申请到足够的内存时抛出。  </p></li><li><p>本地方法栈<br> 虚拟机栈为虚拟机执行Java方法服务，而本地方法栈（Native Method Stack）则为虚拟机使用到的Native方法服务。由于在虚拟机规范中没有强制规定其格式，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接把这两个栈合二为一。和虚拟机栈一样，本地方法栈也抛出相同的两个异常：StackOverflowError和OutOfMemoryError。  </p></li><li><p>Java堆<br> 对于大多数应用，<em>Java堆（Java heap）</em>是Java虚拟机所管理内存中最大的一块。Java堆在虚拟机启动时创建，是被所有线程<em>共享</em>的一块内存区域。此内存区域唯一目的是<strong>存放内存对象实例</strong>。<br> Java堆是<strong>垃圾收集器</strong>管理的主要区域，很多时候被称为<strong>GC堆</strong>，即 <strong>Garbage Collected Heap</strong>。<br> Java堆的细分：从内存回收角度，由于现在的收集器基本采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为新生代和老年代。<br> 从内存分配角度，被线程所共享的Java堆中还可以分出多个线程私有的<em>分配缓冲区</em>。不过划分与存放内容无关，划分的目的是为了更好的回收内存，或者更快地分配内存。<br> Java堆可以处于物理上不限续的内存空间中，只要逻辑上连续即可。大多数实现为大小可扩展的，如果在堆中没有完成实例分配且堆也无法扩展时，将抛出<em>OutOfMemoryError</em>异常。  </p></li><li><p>方法区<br> 和Java堆一样，方法区<em>Method Area</em>和Java堆一样是各个线程<em>共享</em>的内存区域，用于存储已经被虚拟机加载过的类信息、常量、静态变量即时编译后的代码等数据。别名“非堆<em>Non- Heap</em>”，目的是和Java堆区分。当方法区内存不够用时，抛出OutOfMemoryError异常。  </p></li><li><p>运行时常量池<br> 运行时常量池（<em>Runtime Constant Pool</em>）是方法区的一部分。class文件有一项信息是<em>常量池</em>，用于存放编译期生成的各种字面量和符号引用，在类加载后，这部分内容进入方法区的运行时常量池中存放。但运行时常量池相对于class文件常量池的一个明显特征是<strong>具备动态性</strong>，Java不要求常量只能在编译期间产生，也就是说进入运行时常量池中的内容不一定全部要来自于class文件中常量池的预置，运行期间可以有新的常量进入运行时常量池中。这种特性用的比较多的是String类的intern方法。<br> 由于是方法区的一部分，运行时常量池自然被方法区限制，在内存不够用时抛出OutOfMemoryError异常。  </p></li><li><p>直接内存<br> 直接内存不属于Java虚拟机规范中定义的内存区域。这部分内存被频繁使用，且可能导致OutOgMemoryError出现。如果服务器管理员在配置虚拟机参数时忽略直接内存，使得整个内存区域总和大于物理内存限制，从而导致动态扩展时发生OutOfMemoryError异常。  </p><h2 id="2-HotSpot虚拟机对象"><a href="#2-HotSpot虚拟机对象" class="headerlink" title="2. HotSpot虚拟机对象"></a>2. HotSpot虚拟机对象</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p> <strong>检查参数</strong>：虚拟机遇到new指令时先<strong>检查这个指令的参数</strong>，是否能在常量池中定位到一个类的符号引用，并检查该符号引用代表的类是否被加载、解析、初始化过。如果没有则必须先执行相应的类加载过程。<br> <strong>分配内存</strong>：之后虚拟机为新生对象<strong>分配内存</strong>，该过程等同于把一块确定大小的内存从Java堆中划分出来。两种分配方式分别为：<strong>指针碰撞</strong>和<strong>空闲列表</strong>。<br> <strong>指针碰撞</strong>：如果Java堆内存绝对规整，所有用过的内存放在一边，空闲的放在另一边，中间分界点用一个指针标示。那么在分配内存时只需要把指针向空闲方向移动一段和对象大小相等的距离。<br> <strong>空闲列表</strong>：Java堆内存不规整，已使用的内存和空闲内存交错，此时虚拟机维护一个记录空闲内存块的表，记录哪些内存块可用，分配时找一块足够大的空间划分给对象，并更新列表上的记录。<br> 具体采用何种方式由Java堆规整程度决定，而Java堆规整程度又由虚拟机<strong>垃圾收集器</strong>所采用的<strong>垃圾收集算法</strong>决定：典型地，采用<strong>标记-整理</strong>算法，指针碰撞适用；采用<strong>标记-清除</strong>算法，空闲列表适用。<br> 注意内存分配的一个问题，那就是对象创建是一个非常频繁的行为。并发情况下即便是移动一个指针的位置，该操作也是<strong>线程不安全的</strong>。解决方案有两种：对内存分配动作<strong>同步处理</strong>或将内存分配动作按照线程划分在不同空间中进行，即为每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>，即Thread Local Allocation Buffer，<strong>TLAB</strong>。哪个线程要分配内存就在该线程的TLA B上分配，只有TLAB用完而分配新的TLAB时才需要进行同步锁定操作。虚拟机是否使用TALB可以由参数设定。<br> <strong>初始化</strong>：虚拟机将需要分配到的内存空间都初始化为0值。这一操作保证了对象的实例字段在Java代码中可以不赋值就直接使用，程序可以访问到这些字段的数据类型对应的零值。<br> <strong>必要设置</strong>：设置对象的哈希码、GC分代年龄等信息，存放在对象头中。<br> <strong>init方法</strong>： 执行完上述方法后从虚拟机角度看新的对象已经诞生了，但从Java程序视角来看对象创建才刚刚开始——init方法还没有执行，所有字段都还为0。执行init后一个真正可用的对象才创建出来。<br>![](/img/posts/Java虚拟机整理/对象创建过程.png</p><h3 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h3><p> HotSpot虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>Header、<strong>实例数据</strong>Instance Data、<strong>对齐填充</strong>Padding。<br> <em>对象头</em>：包含两部分信息：用于存储对象自身的<strong>运行时数据</strong>和<strong>类型指针</strong>。对象需要存储的运行时数据很多，如哈希码、GC分代年龄、锁状态标志、偏向时间戳等。类型指针则是对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例。并非所有虚拟机实现都必须在对象数据上保留类型指针，即查找对象的元数据信息不一定要经过对象本身。如果对象是一个Java数组，那么对线头中还必须有一块用于记录数组长度的数据，因为虚拟机从数组的元数据中不能确定其大小（但是可以通过普通Java对象的元数据确定Java对象的大小）。<br> <em>实例数据</em>：存储对象<em>真正存储的有效信息</em>，即在程序代码中定义的各种类型的字段内容。这部分的存储顺序受到<em>虚拟机分配策略参数</em>和<em>字段在Java源码中定义顺序</em>的影响。<br> <em>对齐填充</em>：不必要且没有特别含义，作为占位符存在。  </p><h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p> Java操作具体的堆上的对象需要通过栈上的<em>reference</em>（指针）数据。reference类型在Java虚拟机规范中只规定了一个对象引用，并没有定义这个引用应该通过何种方式去定位和访问堆中具体对象的位置，所以对象的访问方式取决于<em>虚拟机的具体实现</em>。目前主流访问方式有使用<em>句柄</em>和<em>直接指针</em>两种。<br> <em>句柄</em>访问方式的实现：Java堆中划分一块内存作为句柄池，reference对象中存储的是对象的句柄地址，而在句柄中包含了对象实例数据与类型数据各自的地址信息。<br> <img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.jpg"><br> <em>直接指针</em>访问实现：Java堆对象布局中必须考虑如何放置访问类型数据的相关信息，而reference中直接存储对象地址。<br> <img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.jpg"><br> 优缺点：句柄方式的最大优点就是reference中存储稳定的句柄地址，在对象被移动时只改变实例数据指针，reference本身不需要修改；直接指针方式优点是访问速度快，节省了一次指针访问的开销。 </p></li></ol><h1 id="三、垃圾收集器与内存分配策略"><a href="#三、垃圾收集器与内存分配策略" class="headerlink" title="三、垃圾收集器与内存分配策略"></a>三、垃圾收集器与内存分配策略</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><pre><code>*垃圾收集器*（Garbage Collection，GC）历史比Java久远。经过半个多世纪的发展，目前内存动态分配与回收技术已经相当成熟。理解GC和内存分配，有助于我们排查各种内存溢出、内存泄漏问题，攻克垃圾收集称为系统达到更高并发的瓶颈。回顾主题二中的介绍，我们知道程序计数器、Java虚拟机栈、本地方法栈这三区域是*线程私有的*，和线程共存亡；这几个区域的内存分配和回收都具有确定性，因为每一个栈帧中分配多少内存，大体可以认为在类结构确定下来时就是已知的，在这几个区域不必考虑回收问题。但是Java堆和方法区不同，一个接口中的多个实现类需要的内存可能不同，一个方法多个分支的内存也不一样，只有在程序运行期间才知道会创建哪些对象，这部分的内存分配和回收都是*动态的*，GC关注的就是这部分内存。  </code></pre><h2 id="2-对象是否死亡的判断"><a href="#2-对象是否死亡的判断" class="headerlink" title="2. 对象是否死亡的判断"></a>2. 对象是否死亡的判断</h2><pre><code>### 引用计数算法引用计数法*Reference Count*简单来说就是给对象中添加引用计数器，每当引用一次，计数器加一，引用失效时就减一。实现简单，判定效率高，但存在的致命问题是无法解决对象间相互引用！也就是因为这个原因，主流Java虚拟机中没有选用此方法。  ### 可达性分析法可达性分析（*Reachability Analysis*）被主流的商用程序语言应用。基本思路是通过一系列称为“*GC Roots*”的对象作为起始点，从这些结点开始向下搜索，搜索走过的路径称为*引用链（Reference Chain）*，当一个对象到GC Roots没有任何引用链相连时（图论中所谓“不可达”），证明此对象是不可用的。如图所示的object4、5、6被认为是可回收的对象。</code></pre><p><img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.jpg"><br>    ### 再谈引用<br>    上述的两种死亡判断算法都与引用有关。但是如果我们要描述这样的对象：在内存相对空闲时，能保留在内存中；但是在内存紧张时，这类对象可以被GC回收。我们根据引用的强弱程度对引用的概念进行了扩充，从强到弱依次为：强引用、软引用、弱引用、虚引用。<br>    ### 对象的自救<br>    即使在可达性分析中判定为可回收的对象，也不是“非死不可”的。可达性分析判定为可回收时，该对象处于“缓行”阶段，要真正宣判“死刑”，至少要经历两次<em>标记</em>过程。如果对象在可达性分析中判定为不可达，那么将会被第一次标记并进行一次筛选，筛选条件时次对象是否有必要执行finalize（）方法。如果当前对象未覆盖finalize方法，或finalize方法已经被虚拟机调用过了，虚拟机将这两种情况都视为“没有必要执行”。<br>    如果对象被判定为有必要执行finalize方法，那么它基本被宣告“死刑”了。但是此时的对象仍然有逃脱的机会。当被判定有必要执行finalize时，对象会被放在一个叫<em>F- Queue</em>的队列中，并在稍后由一个虚拟机建立的、低优先级的<em>Finalizer线程</em>去触发这个方法。所谓的触发是指虚拟机触发这个方法，但不保证会等待它执行结束。处在这个状态中的“犯人”们等待GC对F- Queue中的对象打上第二次小规模的标记。此时如果他们足够幸运，有机会改判“无期徒刑”：当Finalize方法执行缓慢或者死循环，很可能导致F- Queue队列中其他对象处于永久等待！或者也可以选择“改过自新”拯救自己——重新与引用链上的任何一个对象建立关联，那么在第二次标记时将被移出即将回收的集合。如果运气很差又“执迷不悟”的话，那它就真的被回收了。<br>    现在建议各位忘记finalize（）方法的存在——即时上述的例子足够生动地描述了这个过程。该方法运行代价高昂，不确定性大。它所能做的所有工作，使用try-finali或其他方法都能做的更好。  </p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h2><pre><code>### 标记-清除算法 标记-清除（Mark- Sweep）算法正如其名，先标记出所有要回收的对象，完成后统一回收所有带标记的对象。作为最基础的收集算法，标记-清除算法存在以下问题：首先是效率问题，两个过程的效率都不高；其次是产生大量内存碎片——还记得吗，我们之前讨论内存分配时说到具体的分配方法和GC采用的垃圾收集算法有关，如果虚拟机采用标记-清除法的垃圾收集器，那么分配Java堆内存时采用*空闲列表*的方法。  ### 复制算法复制（Coping）算法将可用内存容量分为两块，每次使用其中的一块。当这一块内存使用完了，就将存活的对象全部复制到另一块，再把使用过的这一半全部清理掉。实现简单，运行高效。  现在的商业虚拟机使用该方法回收*新生代*的对象。新生代98%对象都是朝生夕死的，所以不需要按照1:1比例划分空间，而是分为一块较大的*Eden空间*和两块较小的*Survivor空间*，回收时将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，再清理掉Eden和刚才使用过的Survivor空间。HotSpot默认的Eden和Survivor空间大小是8:1，也就是说只有10%空间被“浪费”。当然我们没法保证每次回收都只有不到10%对象存活，当Survivor空间不足时，需要依赖*老年代*进行**分配担保**（*Handle Promotion*）。  </code></pre><p>分配担保：如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活的对象时，这些对象将直接分配进入老年代。  </p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><pre><code>根据老年代的特点，标记-整理（Mark- Compact）算法应运而生。标记过程和标记-清除算法相同，但后续不是进行清理而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。  </code></pre><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><pre><code>当前的商业虚拟机都采用分代收集（Generational Collection）算法，将Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代每次垃圾收集都有大量对象被清除，就采用复制算法；而老年代对象存活率高，使用标记-清除或标记-整理算法回收。  </code></pre><h2 id="4-HotSpot算法实现"><a href="#4-HotSpot算法实现" class="headerlink" title="4. HotSpot算法实现"></a>4. HotSpot算法实现</h2><h3 id="枚举GC-Roots"><a href="#枚举GC-Roots" class="headerlink" title="枚举GC Roots"></a>枚举GC Roots</h3><pre><code>以可达性分析中从GC Roots节点找引用链为例，可以作为GC Roots的节点主要在全局性的引用与执行上下文中。现在很多应用仅方法区就很大，如果逐个检查其中的引用，必然带来大的内存消耗和时间。  另外讨论*GC停顿*——可达性分析工作必须在一个确保一致性的快照中进行，这里的一致性指在整个可达性分析期间，整个执行系统看起来就像被冻结在某个瞬间了一样，也就是说在分析过程中对象引用关系不能处在变化中，否则分析结果的准确性就没有保证。这点是导致GC进行时必须停顿所有Java线程（Sun将这件事称为“Stop The World”）的一个重要原因。  由于目前的主流Java虚拟机都使用了*准确式GC*，很好解决了第一个找引用的问题。当执行系统停顿下来后，不需要一个不漏的检查完所有执行上下文和全局变量的引用位置，虚拟机有办法直接得知哪些地方存放对象引用。在HotSpot实现中就是使用一组称为OopMap的数据结构实现这个目的。类加载完成时HotSpot就把对象内什么偏移量处是何种类型的数据算出来，在JIT编译过程中也会在指定位置记录下栈和寄存器中哪些位置是引用。这样GC在扫描时可以直接得知这些信息。  </code></pre><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><pre><code>在OopMap协助下HotSpot可以快速完成GC Roots枚举，为了避免OopMap内容变化指令太多而带来的存储空间成本太高的问题，实际上HotSpot也没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，这些位置称为*安全点（Safe point）*，即程序执行时，并非在所有地方都能停下来GC，只有到达安全点时才能暂停。对于安全点另一个考虑的问题是，如何在GC发生时让所有的线程都跑到最近的安全点上再停顿下来。现在广泛采用的是*主动式中断*方式，当GC需要开始Stop The World时，不对线程操作，而是设置一个标志，线程轮询这个标志，发现中断标志为真就自己中断挂起来，轮询标志的设置当然是和安全点重合的。  </code></pre><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><pre><code>如果在发生GC时，有的线程处于Sleep和Block的状态，那么它肯定不能相应JVM的中断请求，也不能自己查询标志。这种情况需要*安全区域*解决。  安全区域指在一段代码片段之中，引用关系不会发生变化。此区域中任意地方开始GC都是安全的，也可以理解为其中每一个地方都是Safe point。线程执行到Safe Region中的代码时，高高标识自己进入了“安全区”，这样在JVM要发起GC时就不用管标示为安全的线程了。线程离开安全区域时要检查系统是否已经完成了GC Roots枚举，完成了就继续执行，否则要等待直到收到离开Safe Region的信号为止。    </code></pre><h2 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h2><pre><code>收集算法是垃圾收集的方法论，垃圾收集器是具体的实现。JVM规范中对垃圾收集器的实现没有规定，因此不同厂商提供的垃圾收集器可能有很大差别。这个主题的目的是我们会选择对具体应用最合适的收集器。</code></pre><h3 id="（1）Serial收集器"><a href="#（1）Serial收集器" class="headerlink" title="（1）Serial收集器"></a>（1）Serial收集器</h3><pre><code>最基本的收集器就是serial收集器了，是一个*单线程*的收集器，单线程的意思是它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，*必须暂停其他所有的工作线程直到他收集结束*。这对用户来说是难以接受的——你的计算机每工作一小时就暂停响应5分钟，这对很多电脑游戏爱好者来说比洗澡时停水还让人难受。  但实际上到现在为止Serial收集器依靠它的简单和高效依然被运行在Client模式下的JVM设置为默认的新生代收集器。用户桌面场景中，由于分配给JVM的内存一般不会很大，停顿时间可以控制在一百毫秒内。所以Serial对于运行在Client模式下的虚拟机来说是个很好的选择。  </code></pre><h3 id="（2）ParNew收集器"><a href="#（2）ParNew收集器" class="headerlink" title="（2）ParNew收集器"></a>（2）ParNew收集器</h3><pre><code>Serial收集器的多线程版本。除了多线程收集外，其他与Serial收集器没有太大创新之处。但它确实许多运行在*Server模式*下的虚拟机中首选的新生代收集器（我们提到过许多虚拟机实现对新生代和老年代采用不同的收集器），主要原因是除了Serial外只有ParNew收集器可以和CMS收集器配合工作（CMS稍后介绍，他是HotSpot虚拟机中第一款真正意义上的并发收集器，第一次实现了垃圾收集线程和用户线程基本上同时工作）。</code></pre><h3 id="（3）Parallel-Scavenge收集器"><a href="#（3）Parallel-Scavenge收集器" class="headerlink" title="（3）Parallel Scavenge收集器"></a>（3）Parallel Scavenge收集器</h3><pre><code>新生代收集器，同样使用复制算法且是并行的多线程处理器。特点是它的关注点和其他收集器不同——相比于其他收集器关注尽量缩短GC发生时用户线程的停顿时间，Parallel Scavenge 收集器强调达到一个可控制的*吞吐量*（Throughput）。假定*运行用户代码时间*为 T ，则吞吐量=T/T+垃圾收集时间）。高吞吐量可以高效利用CPU时间，尽快完成运算任务，适合运行在后台而不需要过多交互的任务。  </code></pre><h3 id="（4）Serial-Old收集器"><a href="#（4）Serial-Old收集器" class="headerlink" title="（4）Serial Old收集器"></a>（4）Serial Old收集器</h3><pre><code>Serial收集器的老年版本，是一个使用*标记-整理*算法的单线程收集器，这个收集器的主要意义也是给在Client模式下的虚拟机使用。  </code></pre><h3 id="（5）Parallel-Old收集器"><a href="#（5）Parallel-Old收集器" class="headerlink" title="（5）Parallel Old收集器"></a>（5）Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年版本，使用<em>多线程</em>和<em>标记-整理</em>算法。在Parallel Old收集器出现后，“吞吐量优先”收集器终于有了名副其实的应用组合，在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><h3 id="（6）CMS收集器"><a href="#（6）CMS收集器" class="headerlink" title="（6）CMS收集器"></a>（6）CMS收集器</h3><pre><code>CMS（Concurrent Mark Sweep）收集器是一种以*获取最短回收停顿时间*为目标的收集器。由于现在很大一部分的Java应用集中在互联网站服务器山，这一类应用尤其重视访问速度，CMS非常符合这类网站的需求。  从名字上就可以看出CMS是基于标记-清除算法实现的，运作过程分为四个步骤： *初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）、并发清除（CMS concurrent sweep）。  *其中，初始标记、重新标记这两步骤仍然需要“Stop The World”，初始标记仅仅是标记一下GC Roots关联到的对象，速度很快；并发标记阶段是进行GC Roots Tracing过程，而重新标记阶段是为了修正并发标记期间因为用户程序继续运作而导致的标记变动，这一部分时间也很短。也正是由于过程中耗时最长的并发标记和并发清除过程中，收集器都可以和用户线程*同时工作*，因此总体上CMS收集器的内存回收过程是和用户线程一起并发执行的。  **CMS的缺点：** 1. 对CPU资源敏感。并发期间由于占用CPU资源导致应用程序变慢。  2. 无法处理浮动垃圾（Floating Garbage）。由于CMS并发清理阶段用户线程还在继续工作，自然还会有新的垃圾产生，这部分垃圾出现在标记过程之后，CMS无法在本次回收过程中清理他们，只能等待下一次GC。这部分垃圾称为*“浮动垃圾”*。     3.CMS基于标记-清除算法实现决定了收集结束时有大量内存碎片产生，从而给大对象的内存分配带来麻烦，无法为大对象找到合适的内存，不得不提前触发一次Full GC。      </code></pre><h3 id="（7）G1收集器"><a href="#（7）G1收集器" class="headerlink" title="（7）G1收集器"></a>（7）G1收集器</h3><pre><code>G1收集器（Garbage-First）是一款面向服务端应用的垃圾收集器。具备以下特点：     1. 并行与并发：充分利用多核、多CPU的优势，缩短Stop The World时间。     2. 分代收集：同其他的收集器相同，分代概念在G1收集器中得以保留。虽然G1可以不和其他的GC配合就独立管理整个GC堆，但能采用不同方式处理新对象和多次熬过GC的旧对象。  3. 空间整合：整体上来看G1是基于“标记-整理”算法的收集器。从局部（两个Region）来看是采用“复制”算法的收集器。这意味着在GC期间不会产生内存碎片，GC后，可以提供相对规整的内存。这种特性有利于长期运行程序。   4. 可预测停顿：除了追求低停顿外，G1 还能建立可预测的停顿时间模型，可以让用户指明在未来M毫秒时间段内，消耗在GC过程的时间不超过N毫秒。这几乎已经是实时Java（RTSJ）的垃圾收集器特征了。   *原理*：G1之前的其他收集器都将收集范围都是整个新生代或老年代，而G1将整个Java堆划分为多个大小相等、不需要连续的*独立区域*集合（Region），虽然保留了新生代和老年代的概念，但是他们已经不是物理隔离的了。G1之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪每个Region里面的垃圾堆积的*价值*大小，这个“垃圾的价值”由回收所能获得的空间大小和回收所需时间的经验值来衡量。G1跟踪这个价值并在后台维护一个*优先列表*，每次根据允许的收集时间，优先回收价值最大的Region，这也是G1名称Garbage First的来由。  也许有人注意到了，把Java堆分成若干Region后，GC过程就真的可以以Region为单位进行了吗？换句话说，一个Region不可能是孤立的，一个对象分配在某个Region中，并不能限定它只能和本Region中的其他对象之间发生引用，而是可以和Java堆中任何对象发生引用关系。难道把人类划分为几大家族，家族之间就不允许联姻了吗？正因如此，在可达性分析时岂不是还要扫描整个Java堆才能保证其准确性？  值得注意的是，这个问题不是只出现在G1中，只是G1中更明显。实际上，无论是G1收集器中Region之间的对象引用，还是其他收集器中的新生代和老年代之间的引用，虚拟机都是使用*Remembered Set*避免全堆扫描的。简单来说，每个Region中都有对应的Remembered Set，当程序对Reference类型的数据写操作时，会暂时中断写操作（通过一个Write Barri），检查Reference引用的对象是否处于不同Region之间（分代中就是检查老年代对象是否引用了新生代对象），如果是就通过Card Table把相关记录信息记录到被引用对象所属Region的Remembered Set中。内存回收时，在GC根节点枚举范围中加入Remembered Set可保证不对全堆扫描也不会遗漏。  忽略对Remembered Set的操作，G1收集器的运作大致分为以下步骤：   初始标记、并发标记、最终标记、筛选回收。      相信很多读者会发现有几个步骤和CMS相似。*初始标记*阶段仅仅标记一下GC Roots能直接关联的对象，修改Next Top at Mark Start，（NTMS）的值。让下一阶段用户程序并发执行时，能在正确可用的Region中创建新对象。初始标记需要时停，但时间很短。*并发标记*阶段开始可达性分析，需要时间长，但可以和用户线程并发执行。*最终标记*阶段为了修正并发标记期间因用户线程而产生变动的记录，虚拟机将变动记录在Remembered Set Logs中，并在此阶段将其并入Remembered Set。这个阶段需要停顿线程，但是可以多线程并行这个过程。最后*筛选回收*阶段对各个Region的“价值”进行排序，并根据用户期望的GC停顿时间制定回收计划。  </code></pre><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><pre><code>GC日志是人为制定的规则，容易理解，只需要参考资料即可，可查阅《深入理解Java虚拟机》（周志明著，第二版，机械工业出版社）P89。  </code></pre><h2 id="6-内存分配策略"><a href="#6-内存分配策略" class="headerlink" title="6.内存分配策略"></a>6.内存分配策略</h2><pre><code>Java体系中的自动内存管理可以归结为自动化解决了两个问题：*给对象分配内存和回收分配给对象的内存*。关于回收我们已经详细介绍过了，接下来看看给对象分配内存时发生了什么。  我们说过现在的商业虚拟机都采用复制算法回收新生代。下面的讨论基于使用Serial/Serial Old收集器。  对象的内存分配就是堆上分配（也可能栈上分配），对象主要分配在新生代的*Eden区*上。如果启用了*本地线程缓冲，TLAB*，将按照线程在TLAB上分配（我们在介绍对象的创建过程时，讨论到对象创建的并发安全性时介绍过TLAB）。分配的规则不是确定的，而是要看当前使用的哪种垃圾回收组合，以及虚拟机相关参数的设置。  </code></pre><h3 id="（1）对象优先在Eden分配"><a href="#（1）对象优先在Eden分配" class="headerlink" title="（1）对象优先在Eden分配"></a>（1）对象优先在Eden分配</h3><pre><code>大多数情况下对象优先在Eden分配。当Eden区空间不足，将发起一次*Minor GC*（新生代垃圾回收）。  虚拟机提供了收集器日志参数，告诉虚拟机在发生GC时打印内存回收日志，并在进程退出时输出当前的内存各区域分配情况。新生代中Eden区和Survivor区的大小比例也可以通过参数设置。  </code></pre><h3 id="（2）大对象直接进入老年代"><a href="#（2）大对象直接进入老年代" class="headerlink" title="（2）大对象直接进入老年代"></a>（2）大对象直接进入老年代</h3><pre><code>典型的大对象是很长的字符串和数组，大对象对虚拟机的内存分配是个实打实的坏消息，尤其是朝生夕死的大对象是更坏的消息。如果把分配一个大对象内存比做服务一个麻烦的顾客，那么一个朝生夕死的大对象就好像是不仅为这个顾客提供了麻烦的服务，最后还要花费更大的精力全额退款。经常出现大对象，内存容易不得不提前触发GC来安置他们。  虚拟机提供了一个参数，只要需要分配内存的对象大小大于这个参数，这个对象就会*直接进入老年代*。  </code></pre><h3 id="（3）长期存活的对象进入老年代"><a href="#（3）长期存活的对象进入老年代" class="headerlink" title="（3）长期存活的对象进入老年代"></a>（3）长期存活的对象进入老年代</h3><pre><code>虚拟机给每个对象定义了一个*对象年龄计数器*。如果对象在Eden出生且第一次Minor GC后仍然存活且能被Survivor容纳的话，根据复制算法，它将进入Survivor中，并且将计数器年龄+1。每熬过一次Minor GC，年龄加一。年龄达到阈值（默认15）时，对象晋升到老年代中。  </code></pre><h3 id="（4）动态对象年龄判定"><a href="#（4）动态对象年龄判定" class="headerlink" title="（4）动态对象年龄判定"></a>（4）动态对象年龄判定</h3><pre><code>并不是只有年龄计数器达到阈值才可以进入老年代。*如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代*。  </code></pre><h3 id="（5）空间分配担保"><a href="#（5）空间分配担保" class="headerlink" title="（5）空间分配担保"></a>（5）空间分配担保</h3><pre><code>我们在复制算法中同样提到过，survivor空间不足时要依靠老年代进行*分配担保*，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代还有足够的容纳空间。  在发生Minor GC之前虚拟机先检查老年代最大可用空间是否大于*新生代所有对象总空间*。如果是，那么本次Minor GC可以认为是安全的。否则查看虚拟机参数设置值是否允许担保失败。如果允许检查老年代剩余空间是否大于*历次晋升到老年代对象的平均大小*，如果大于，将尝试一次Minor GC，尽管冒着风险。如果小于或者虚拟机设置为不允许担保失败，那么改为进行一次*Full GC*。      所谓的“冒着风险”是指如果本次进入老年代的存活对象大小激增，超出了历次平均的经验值，依然导致*担保失败（Handle Promotion Failure）*，只好在失败后重新发起Full GC，这样就绕了一大圈。即便如此一般也将虚拟机设置为允许担保失败，可以避免过于频繁的Full GC。</code></pre>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>一、JVM大纲</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统大纲</title>
    <link href="/2020/08/08/Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E7%BA%B2/"/>
    <url>/2020/08/08/Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>进程在运行时，可以在自己的地址空间存储一定量的信息。采用这种信息存储方式有三个问题：<br>（1） 这些地址空间所能存储的信息十分有限。<br>（2）信息可能随着进程的终止而丢失。<br>（3）一个进程中的信息不能并发的被多个进程同时访问。<br>解决方法：<br>使信息的存储独立于任何一个进程。<br>那么怎么存储这些信息，解决以上三个问题呢？<br>存储信息可以使用磁盘(magnetic disk)。使信息独立出来被存储。然而还有问题：<br>（1）怎么直接快速找到想要的信息；<br>（2） 怎么防止一个用户访问别的用户的信息（服务器经常遇到的问题）；<br>（3） 怎么知道哪一块是空闲的。<br>要解决磁盘存储带来的问题，我们建立了文件这个抽象。</p><h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h2><h3 id="文件的定义："><a href="#文件的定义：" class="headerlink" title="文件的定义："></a>文件的定义：</h3><p>文件是进程所创建的信息逻辑单元，受操作系统管理。进程可以读取已经存在的文件并且在需要的时候创建新的文件。操作系统中处理文件的部分称为文件系统。</p><h3 id="文件的结构"><a href="#文件的结构" class="headerlink" title="文件的结构"></a>文件的结构</h3><p>文件有三种构造结构：字节序列、记录序列和树。<br>首先，操作系统并不关心文件是什么内容，它只在乎自己管理的字节。文件内容和含义只在用户程序中解释，操作系统只把文件看做字节序列。用户可以向文件中加入任何想要的或特殊的内容，操作系统不会提供任何帮助，但也不构成任何障碍。把文件看做字节，给操作系统提供了最大的灵活性。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型，只讨论普通文件。<br>普通文件: 包含用户信息的文件，分为二进制文件和ASCII文件。<br>ASCII文件：可以显示和打印，可以用任何编辑器编辑。采用这种文件作为输入输出有利于一个程序的输出作为另外一个的输入。<br>二进制文件：有一定的内部结构，使用该文件的程序才了解此结构。只有文件的格式正确时，操作系统才会执行这个文件。</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>存储介质是磁带时，顺序访问方式是很方便的。<br>不按次序访问文件或目录，这种方法称为随机访问文件。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件的的附加信息称为文件的属性，不同的操作系统文件的属性各不相同。</p><h2 id="二、目录"><a href="#二、目录" class="headerlink" title="二、目录"></a>二、目录</h2><p>文件系统提供目录或者文件夹，用于记录文件的位置。</p><h3 id="（1）一级目录系统"><a href="#（1）一级目录系统" class="headerlink" title="（1）一级目录系统"></a>（1）一级目录系统</h3><p>最简单的形式，一级目录系统在一个目录中包含所有的文件，这个目录称为根目录。</p><h3 id="（2）-层次目录系统"><a href="#（2）-层次目录系统" class="headerlink" title="（2） 层次目录系统"></a>（2） 层次目录系统</h3><p>目录树结构的文件系统</p><h3 id="（3）-路径名"><a href="#（3）-路径名" class="headerlink" title="（3） 路径名"></a>（3） 路径名</h3><p>用层次文件系统指定文件所在位置时，常用两种指定方法：绝对路径名和相对路径名。<br>绝对路径名：从根目录到文件的路径。<br>特点：一定从很目录开始，并且唯一。以三种操作系统为例：<br>Windows  \usr\ast\mailbox<br>UNIX     usr/ast/mailbox<br>MULYICS     &gt;usr&gt;ast&gt;mailbox<br>相对路径名：和当前工作目录一起使用。当前工作目录可以由用户指定。<br>所有的不从根目录开始的路径名都是相对路径名。相对路径往往更加方便，功能也和绝对路径完全相同。<br>那么如何选择路径名呢？<br>如果要访问某一个特定的文件而不考虑当前用户的目录，应采用绝对路径。反之可以选择相对路径。无论用户处在哪个目录下，绝对路径总是能很好的工作。<br>特殊的目录项：”.” 和”..” . 指当前目录， .. 指的是父目录（根目录中指向他自己）。</p><h2 id="三、文件系统的实现"><a href="#三、文件系统的实现" class="headerlink" title="三、文件系统的实现"></a>三、文件系统的实现</h2><p>我们关心文件和目录是怎么样存储、磁盘空间怎么样管理的，以及怎么保证系统有效持续工作。下面解决这些问题。</p><h3 id="1-文件系统布局"><a href="#1-文件系统布局" class="headerlink" title="1.文件系统布局"></a>1.文件系统布局</h3><p>文件系统存放在磁盘上。多数的磁盘被划分为一个或多个分区，每一个分区中有一个独立的文件系统。磁盘中的0号扇区被称为主引导记录(Master Boot Record , MBR)用于引导计算机。MBR的结尾是分区表。给出了每一个分区的开始和结束地址。分区表中有一个分区被标记为活动分区。计算机被引导时，BIOS读入并执行MBR。MBR首先确定这个活动分区并读入它的第一个块——引导块，并执行。引导块中的程序将装载该分区的操作系统。统一起见，每个分区都从一个引导块开始，即使这个块没有可启动的操作系统。<br>除了从引导块开始这个统一的特点，磁盘分区布局随着文件系统的不同而变化，但通常含有下列的项目：超级块、空闲的信息、i节点、根目录</p><h3 id="2-文件系统的实现"><a href="#2-文件系统的实现" class="headerlink" title="2.文件系统的实现"></a>2.文件系统的实现</h3><p>实现的关键问题：记录各个文件分别用到哪个磁盘块。</p><h4 id="（1）连续分配"><a href="#（1）连续分配" class="headerlink" title="（1）连续分配"></a>（1）连续分配</h4><p>把文件作为一系列的连续数据存在磁盘上。例如在块大小为1KB的磁盘上，50KB的文件要分配50个连续的块。注意每个文件都从一个新块开始，也就是说如果有一个文件占据了2.5块的空间那么将有0.5块空间被浪费。<br>连续分配的优势：<br>· 实现简单：只需要记住两个信息即可——第一块的磁盘地址和文件的块数。<br>· 读操作性能好。只需寻找第一个块就可以实现方便的读操作。<br><strong>缺点：</strong><br>长时间使用磁盘空间会变得零碎。首先，我们知道有些文件占用不完一整个磁盘块，但文件的存储都是从完整的块开始的；另外如果有文件被删除，那么会留下一大块空闲块<br>；用户向这个块中存储信息，那么信息的大小会被限制——不能超出这个空闲块的大小；如果存储可变的信息，我们不能要求用户提前告知信息的大小；反之如果信息量较小，那么仍然会存在未利用空闲区。尽管可以压缩磁盘，但是涉及到几乎所有文件的复制和再存储，成本代价高昂。</p><h4 id="（2）链表分配"><a href="#（2）链表分配" class="headerlink" title="（2）链表分配"></a>（2）链表分配</h4><p>为每个文件构造磁盘块链表，每个块的第一个字作为指向下一个块的指针，块的其他部分则用来存放数据。<br><strong>优点：</strong><br>（1）充分利用每一个磁盘块，不会出现连续存储的问题——有过多磁盘碎片而浪费空间（除了最后一块的内部碎片）<br>（2） 顺序访问非常方便。<br><strong>缺点：</strong><br>（1）随机访问十分缓慢。<br>（2） 由于指针占有一定的字节，每一个磁盘块存储数据的字节数不再是2的整数次幂。</p><h4 id="（3）采用内存中的表进行链表分配"><a href="#（3）采用内存中的表进行链表分配" class="headerlink" title="（3）采用内存中的表进行链表分配"></a>（3）采用内存中的表进行链表分配</h4><p>上述链表的两个不足都可以通过这个方式解决：取出每个磁盘块的指针字，把他们一同存放到内存的某个表中。内存中这样的一个表格叫做文件分配表（FAT）。<br>由于整个链表都存放在内存中，所以不需要任何磁盘引用。<br>缺点：必须把整个表都存放在内存中。</p><h4 id="（4）i-节点"><a href="#（4）i-节点" class="headerlink" title="（4）i 节点"></a>（4）i 节点</h4><p>i节点中列出了文件属性和文件块的磁盘地址，是另外一种记录各个文件分别包含哪些磁盘块的方法。<br>优势：给定i节点就能找到文件的所有块。只有对应的文件打开时，他的i 节点才在内存中。相比其他的记录方法，节约了一定的内存空间。</p><h3 id="3-目录的实现"><a href="#3-目录的实现" class="headerlink" title="3.目录的实现"></a>3.目录的实现</h3><p>目录系统的主要功能是把ASCII文件名映射成定位文件数据所需的信息。<br>文件属性可以存放在目录中，也可以存放在i节点中。相比之下第二种方法更好。<br>可变长度的文件名怎么实现？<br>几乎所有的现代操作系统都支持可变长度的文件名。处理有三种方法：<br>· 直接给文件名一个长度限制为每个文件名保留固定大小的空间。<br>· 改变目录项的大小<br>· 目录项长度固定，将文件名放在目录后面的堆中。<br>如何快速查找文件？<br>除了从前到后线性地搜索文件，加快文件搜索速度的一个方法是在每个目录中使用散列表：添加一个文件时，与散列值对应的散列表表项进行检查。如果该表项未被使用，就将一个指向文件目录项的指针放入，文件目录项紧跟散列表之后。反之，构造一个链表表头存放在该表项中，并且连接所有的相同的散列值的文件目录项。</p><h3 id="4-共享文件"><a href="#4-共享文件" class="headerlink" title="4.共享文件"></a>4.共享文件</h3><p>拥有共享文件的系统文件系统A和B，如果A中的一个文件也出现在B的目录下，那么B的目录和该共享文件的联系称为一个链接。这样文件系统本身是一个有向无环图。</p><h3 id="5-日志结构文件系统-Log-structured-File-System-LFS"><a href="#5-日志结构文件系统-Log-structured-File-System-LFS" class="headerlink" title="5.日志结构文件系统( Log-structured File System, LFS )"></a>5.日志结构文件系统( Log-structured File System, LFS )</h3><p>CPU运行速度越来越快，磁盘空间越来越大，磁盘的高速缓存也在不断增加，但是磁盘的寻道时间没有得到快速发展。大多数文件系统中，写操作都是零碎的。这也意味着增加更多的寻道时间，磁盘的利用率降低到1%以下。<br>日志结构文件系统旨在解决这样的问题：即使面对一个很多的零碎的写操作组成的任务，CPU同样能够充分利用磁盘的带宽。其基本思想是将整个磁盘结构化为一个日志：<br>每隔一段时间，被缓冲在内存中的未决定的写操作，都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。同时，为了找到i节点，LFS利用维护一张由i节点编号索引组成的i节点图来索引文件。<br>为了检查哪些旧的磁盘块仍然占用着先前段的空间，LFS提出了清理线程。周期性的扫描日志并进行压缩：先读取日志中第一个段的摘要，检查有哪些i 节点和文件；然后清理线程查看当前i节点图，判断节点是否有效，文件是否仍然在使用中；如果没有使用，该信息被丢弃。</p><h3 id="6-日志文件系统"><a href="#6-日志文件系统" class="headerlink" title="6.日志文件系统"></a>6.日志文件系统</h3><p>相比于日志结构的文件系统，日志文件系统的出彩之处在于保存了日志结构文件系统的一个重要思想——保存一个用于记录系统下一步要做什么的日志。假设系统正在完成一个任务时出现了崩溃。那么在重启系统后可以通过查看日志获取崩溃前计划要完成的任务，并继续完成他们。相比于日志结构的文件系统，这种日志文件系统得到了广泛的应用。<br>在移除文件操作中，要进行三个操作：<br>（1）目录中删除文件；<br>（2） 释放i节点到空闲i节点池；<br>（3） 归还磁盘块到空闲磁盘块池。<br>日志文件系统先写一个日志项，列出这三个将要完成的动作；然后这个日志项被写入磁盘；只有日志项写入完毕了，其他的操作才可以进行。所有操作成功后擦除日志项。如果发生崩溃系统可以检查日志项，看看是否有操作未完成，从而完成未完成的工作。<br>被写入日志的操作必须是幂等的。</p><h3 id="7-虚拟文件系统"><a href="#7-虚拟文件系统" class="headerlink" title="7.虚拟文件系统"></a>7.虚拟文件系统</h3><p>Virtual File System 虚拟文件系统关键思想是：抽象出所有文件系统的共有部分，并且将这些代码放在共同的一层；该层调用底层的实际文件系统来具体管理数据。<br>VFS对上层用户提供了调用接口，即POSIX接口；VFS也有一个对于实际文件系统的下层接口，VFS接口，这个接口包含许多功能调用。当创造一个新的文件系统协同VFS工作时，新文件系统的设计者就必须明确要确定他提供的VFS需要的系统调用。<br>当系统启动时，根文件系统在VFS中注册。装载其他文件系统时，也必须在VFS中注册。注册时的操作是提供一个包含VFS所需要的函数地址的列表，每个VFS对象一个。因此只要文件在VFS注册了，VFS就知道怎样从它那读取一个块．</p><h2 id="四、文件系统的管理和优化"><a href="#四、文件系统的管理和优化" class="headerlink" title="四、文件系统的管理和优化"></a>四、文件系统的管理和优化</h2><h3 id="1-磁盘空间管理"><a href="#1-磁盘空间管理" class="headerlink" title="1.磁盘空间管理"></a>1.磁盘空间管理</h3><p>文件通常存放在磁盘上。几乎所有的文件系统都把文件分割成固定大小的块来存储。</p><h4 id="（1）块大小"><a href="#（1）块大小" class="headerlink" title="（1）块大小"></a>（1）块大小</h4><p>文件按照块存储，那么块的大小应该是多少？<br>块大小的选择实际上存在悖论。考虑两个因素：数据率和空间利用率。如果优先选择大的块，那么每一次寻道将能够访问更多的数据，将会有更高的数据率，但是对于小文件，由于只能按照分块存储，总会有一定的空间被浪费；反之如果选择较小的块，空间利用率则会大大提高，但是随之而来的是更多的寻道次数和辗转延迟时间。<br>处理方法：随着目前磁盘的容量超过了TB，我们选择较大的磁盘块，接受空间的浪费提高数据率，因为磁盘空间几乎不会再短缺了。</p><h4 id="（2）记录空闲快"><a href="#（2）记录空闲快" class="headerlink" title="（2）记录空闲快"></a>（2）记录空闲快</h4><h5 id="磁盘块链表"><a href="#磁盘块链表" class="headerlink" title="磁盘块链表"></a>磁盘块链表</h5><p>用块记录空闲磁盘块号。1KB的磁盘块可以存放256个32位磁盘块号—————1KB = 1024B = 8192bit = 256 * 32bit<br>这种方法在内存中保存一个指针块。创建一个文件时，需要的指针从中取出。当现有的指针不够用时，从磁盘中读一个新的指针块。删除文件类似、当指针块几乎为空时，一系列短期的临时文件会引起大量的磁盘I/O。</p><h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><p>windows FAT文件系统采用位图来记录空闲块。n个块的磁盘，需要n位位图。在位图中，空闲快用1表示，已分配的用0表示。因为每一个块只用一个二进制位表示，而链表方法中要用到一个32位的块。只有在磁盘空间几乎块满时，链表方法的空间才比位图少。</p><h5 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h5><p>多用户操作系统常常采用这种强制性机制。确保用户不超过分配给他们的额度。</p><h4 id="2-文件系统的性能"><a href="#2-文件系统的性能" class="headerlink" title="2.文件系统的性能"></a>2.文件系统的性能</h4><p>访问磁盘比访问内存慢得多。许多文件系统都采用各种优化措施改善性能。</p><h5 id="（1）高速缓存"><a href="#（1）高速缓存" class="headerlink" title="（1）高速缓存"></a>（1）高速缓存</h5><p>最常用的减少磁盘访问次数的技术是高速缓存（block cache）或者缓冲区高速缓存（buffer cache）。<br>管理高速缓存也有不同的算法，常用算法是：检查全部的读请求，看他们需要的快是不是在高速缓存中。如果是，直接从缓存中读取。否则，首先先把这些快读入高速缓存，再复制到需要的地方。之后的对这些块的访问请求，都可以直接通过高速缓存完成。<br>高速缓存也有许多块，通常通过散列操作，快速确定高速缓存中有没有所需要的块。如果高速缓存满了，就需要将原来的某些快调出高速缓存。如果对这些快有过写操作，那么要把他们写入磁盘。这种情况类似于分页。实际上，分页算法也都适用于高速缓存。</p><h5 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h5><p>只适用于顺序存储的文件。需要用到块之前，试图将他提前写入高速缓存，从而提高命中率。比如用户请求文件系统在某个文件中生成一个快K，那么文件系统会在用户没有察觉的情况下检查高速缓存，看看K+1是否在其中。如果不在，会安排一个预读。这样用户在想要用到K+1时，这个块已经在高速缓存中了，或者，已经预读过了。</p><h5 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h5><p>将可能顺序存储的块放在一起，从而减少磁盘臂的移动次数。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Andrew S.Tanenbaum著 陈向群 马洪兵 等译 Modern Operating Systems[M]. 原书第三版，机械工业出版社.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2. hexo个人博客的更多基本操作</title>
    <link href="/2020/08/03/hexo/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/08/03/hexo/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><pre><code>本文章内容浅显偏重基本操作，只为初学者提供相关的参考。</code></pre><h3 id="概要：-博客中插入图片；-git下拷贝；-简单更换博客的主题；-博客页面美观化；"><a href="#概要：-博客中插入图片；-git下拷贝；-简单更换博客的主题；-博客页面美观化；" class="headerlink" title="概要： 博客中插入图片； git下拷贝； 简单更换博客的主题； 博客页面美观化；"></a>概要： 博客中插入图片； git下拷贝； 简单更换博客的主题； 博客页面美观化；</h3><pre><code>另外，还不清楚怎么部署博客到多个平台的同学参考：https://actonxidian99.gitee.io/2020/07/30/如何用hexo搭建简易的个人博客/</code></pre><h2 id="关于如何在博客中插入图片"><a href="#关于如何在博客中插入图片" class="headerlink" title="关于如何在博客中插入图片"></a>关于如何在博客中插入图片</h2><pre><code>1. 本地引用，在本地的 source 目录下创建一个图片文件夹 imags，存放图片，在博文文章中通过以下格式引用：假如我创建的images目录下有名为 testimage 的 jpg 格式照片，那么引用为：![](/images/testimage.jpg)这样的Markdown语法即可插入本地图片到博客。2. 远程服务端引用，支持引用</code></pre><h2 id="如何在git下复制文件"><a href="#如何在git下复制文件" class="headerlink" title="如何在git下复制文件"></a>如何在git下复制文件</h2><pre><code>使用命令：cat将电脑本地的文件复制到粘贴板：cat filename &gt; /dev/clipboard粘贴板的内容复制到本地文件（这个本地文件支持txt和doc文件等）：cat /dev/clipboard &gt; filename</code></pre><h2 id="简单地更换博客主题"><a href="#简单地更换博客主题" class="headerlink" title="简单地更换博客主题"></a>简单地更换博客主题</h2><pre><code>更换博客的主题，让你的博客看起来更美观。可以借用hexo提供的模板，在官网hexo.io上可以找到更多模板。以yilia主题为例：网址：github.com/litten/hexo-theme-yilia1. 本地git端下载主题： blog 目录下，git clone https://github.com/litten/hexo-theme-yilia.git themes/yilla 将该网址下的主题复制到本地的themes/yilia目录下。如果和github的链接太慢，可以去下载压缩包，手动解压复制到当前的文件下。当然你需要重命名这个解压文件。2. 进入theme目录下，ls可以看到刚下载的主题。3. 配置到自己的博客：blog目录下再次配置 _config.yml文件：找到Theme，将原来的主题换成yilia.4. 回去blog目录hexo g, hexo s即可在本地端口查看到自己的主题。当然你也可以再立刻 hexo d，和刚才一样。把新的主题格式推到github远端上去。</code></pre><h2 id="博客页面更加美观"><a href="#博客页面更加美观" class="headerlink" title="博客页面更加美观"></a>博客页面更加美观</h2><pre><code>1. 下载你心仪的主题时，注意，在对应的主题说明文件中有相关的详细配置，比如我应用的fluid主题相关的配置文件在：https://hexo.fluid-dev.com/docs/guide/2. 确定主题之后根据相应的详细配置说明文档，更好地布置你博客页面的字体、颜色、图片和链接吧！</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1. 如何用hexo搭建简易的个人博客</title>
    <link href="/2020/07/30/hexo/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/07/30/hexo/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="有关如何用hexo搭建简易个人博客的一些声明"><a href="#有关如何用hexo搭建简易个人博客的一些声明" class="headerlink" title="有关如何用hexo搭建简易个人博客的一些声明"></a>有关如何用hexo搭建简易个人博客的一些声明</h2><p>   本文章的教学范围仅限于搭建简易的个人博客，是参考 codesheep 在B站上的视频<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="codesheep: https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11743305723526974314">[1]</span></a></sup>一步步做出来的，想要深入了解的读者可以去仔细研读。本文章只是对羊哥视频的复盘，仅供仍然存在困难的读者一些参考。作者安装的Windows 64位，和羊哥的Mac版本略有不同。</p><h3 id="概要：搭建hexo博客；-将博客部署到github、码云、coding平台的方法。"><a href="#概要：搭建hexo博客；-将博客部署到github、码云、coding平台的方法。" class="headerlink" title="概要：搭建hexo博客； 将博客部署到github、码云、coding平台的方法。"></a>概要：搭建hexo博客； 将博客部署到github、码云、coding平台的方法。</h3><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol><li><p>安装node.js，下载网址：nodejs.org。</p></li><li><p>Windows需要安装git版本控制工具，bai du git下载就能找到。如果觉得下载太慢或无法打开页面，分享我的百度网盘链接：<a href="https://pan.baidu.com/s/1SnmSX1YhbEf65Sk2TrfEVA">https://pan.baidu.com/s/1SnmSX1YhbEf65Sk2TrfEVA</a> 提取码 dcf8，Windows64位2.27版本的。</p></li><li><p>Windows下载后安装git，在网上搜索安装教程即可，应该是要和node工具在一个目录下，因为在不同目录下的尝试没成功。</p><p>这两部分的安装可参考hexo的官方中文文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></li><li><p>打开git bash。</p></li><li><p>依次输入以下命令</p><p>npm install -g cnpm –rigistry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 先借助cnpm安装<br>cnpm install -g hexo-cli 安装hexo博客框架<br>hexo -v 可以查看当前安装的hexo版本</p><p>mkdir blog 在当前路径建立一个博客目录<br>cd blog/ 进入建立的目录</p><p>hexo init 初始化一个博客，这个过程有时候非常漫长，只要不报错总是好的。</p><p>hexo s 启动博客</p><p>会生成一个本地网址，打开就能看到hexo创建的默认博客。</p></li><li><p>新建一篇文章<br>hexo new “我的第一篇博客”，会生成该文章文件和目录。进入这个目录下，就会看到生成的文件了。之后你可以用vi编辑器写文章内容了，支持Markdown格式。</p></li><li><p>退回到blog目录下，生成编辑文章：hexo g</p></li><li><p>输入 hexo s启动博客，即可看到新添加的博文。</p></li></ol><h2 id="博客的简单布置"><a href="#博客的简单布置" class="headerlink" title="博客的简单布置"></a>博客的简单布置</h2><h3 id="博客配置到github"><a href="#博客配置到github" class="headerlink" title="博客配置到github"></a>博客配置到github</h3><p>   配置博客到github，这样就不必始终在本地端口访问了，可以在生成自己的博客网址了。</p><ol><li><p>登陆github，右上角+号，New repository。</p></li><li><p>命名：自己的昵称.github.io，这个地址会作为博客的网址。</p></li><li><p>命令行，博客的blog路径下输入 cnpm install –save hexo-deployer-git，安装一个插件。</p></li><li><p>安装完成后，ls 打开列表，修改_config.yml文件：vim _config.yml，打开后跳到文件末尾，最后的type: 后面修改如下：</p><p>type: git<br>repo: (这里复制刚才新建的_仓库地址)<br>branch: master</p><p>保存退出.</p><p><img src="/images/configyml.jpg"></p></li><li><p>部署到远端：hexo d ，根据提示输入账号和密码.windows下可能出现错误提示：</p><p><img src="/images/warning.jpg"></p><p> 执行提示中的指令，进行github身份核实：</p><p><img src="/images/word.jpg"></p></li><li><p>刷新github仓库就可以看到更新的内容，此时的仓库名字可以直接在浏览器访问了。</p></li><li><p>无法访问有几种情况：</p><p>（1）用户名和仓库名字不一致，查看自己github的账号名称和创建的库名称是否一致。</p><p>（2）手机端可以打开但是电脑端页面找不到，有可能是网络问题，别人的网络或许可以访问你的博客；或者是本地无法和github通信，后者请参考这篇文章：</p><p><a href="https://www.cnblogs.com/notstandalone/p/12496548.html">https://www.cnblogs.com/notstandalone/p/12496548.html</a></p><p>（3）由于网络问题导致的电脑端无法访问，可以考虑部署博客到国内的平台上。</p></li></ol><h3 id="博客部署到码云"><a href="#博客部署到码云" class="headerlink" title="博客部署到码云"></a>博客部署到码云</h3><p>  国内的部署可以更快地访问。部署到码云的步骤和github基本相同。</p><ol><li><p>注册并且登陆码云。</p></li><li><p>创建一个新的仓库。</p></li><li><p>在码云上添加本地电脑的SSH公钥。</p></li><li><p>配置博客的_config.yml_文件，repo：你的码云仓库网址。</p></li><li><p>如果你的配置文件里已经有github的仓库网址，删除或注释掉它。</p></li><li><p>hexo clean + hexo g + hexo d可以把本地的博客推到码云的仓库里。</p></li><li><p>去到仓库里的“服务“板块，部署打开仓库的pages服务：</p></li></ol><p><img src="/img/posts/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee.png"></p><p>之后会自动产生访问链接啦！</p><h3 id="博客同时部署到多个平台"><a href="#博客同时部署到多个平台" class="headerlink" title="博客同时部署到多个平台"></a>博客同时部署到多个平台</h3><p>  （1）首先需要在这些平台上都创建相应的仓库；</p><p>  （2）修改 _config.yml_文件，repo配置更改示例如下：</p><p><img src="/img/posts/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/repo.png"></p><p>  （3）进入source目录下，创建文件： touch Staticfile，必须是这个文件名。</p><p>  （4）hexo clean + hexo g + hexo d 就可以同时推送到配置的多个平台上。</p><p>  （5）建议尽量部署到国内平台，最后一起推到github上去————因为github推远端时大多时候都要再输入账号密码，这对频繁更新的初学者来说浪费了许多时间。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>   作者后续会进行相应的更新，包括插入图片、超链接、配置更美观的界面等。请关注作者的其他文章。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>codesheep: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11743305723526974314">https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11743305723526974314</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
