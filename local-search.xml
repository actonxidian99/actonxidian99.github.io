<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>“Java虚拟机整理</title>
    <link href="/2020/10/19/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/"/>
    <url>/2020/10/19/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p> <img src="/img/posts/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%95%B4%E7%90%86/Xmind.png"></p><h1 id="Java历史"><a href="#Java历史" class="headerlink" title="Java历史"></a>Java历史</h1><h1 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h1><h2 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><ol><li><p>程序计数器<br> 程序计数器可以看成是<strong>当前线程所执行字节码的行号指示器</strong>。虚拟机的概念模型中，字节码解释器就是通过改变计数器的值来选取下一条需要执行的字节码指令。分支、跳转、循环等基础功能都要依赖计数器完成。<br> 我们都应该知道Java虚拟机的多线程实际上是通过多个线程的轮流切换并分配处理器时间来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，因此为了线程切换后能恢复到正常的位置，每个线程都需要有一个<em>独立的程序计数器</em>，互不影响，独立存储，我们称类似程序计数器这样的内存为“线程私有的内存”。<br> 如果一个线程正在执行一个Java方法，该程序计数器存储的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法则计数器值为空。  </p></li><li><p>Java虚拟机栈<br> Java虚拟机栈同样是线程私有的，生命周期和线程相同。<br> 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个<em>栈帧</em>（Stack frame）存储局部变量表、操作数栈、动态链接等信息方法的调用到执行完毕的过程对应了一个栈帧在虚拟机中入栈和出栈的过程。〈br〉<br> 所谓的<em>局部变量表</em>存放了编译期间可知的各种基本数据类型、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。<br> 其中64位长度的long、double类型数据占用两个局部变量空间（Slot），其余数据类型只占用一个。局部变量表需要的内存空间在编译期间就完成分配，进入一个方法时，该方法在栈帧中分配多大的局部变量空间是完全确定的，运行期间，局部变量表大小不变。<br> Java虚拟机规范中对虚拟机栈规定了两种异常：<strong>StackOverflowError</strong>异常：线程请求的栈深度大于虚拟机栈允许的深度；<strong>OutOfMemoryError</strong>异常：当虚拟机栈进行动态扩展而无法申请到足够的内存时抛出。  </p></li><li><p>本地方法栈<br> 虚拟机栈为虚拟机执行Java方法服务，而本地方法栈（Native Method Stack）则为虚拟机使用到的Native方法服务。由于在虚拟机规范中没有强制规定其格式，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接把这两个栈合二为一。和虚拟机栈一样，本地方法栈也抛出相同的两个异常：StackOverflowError和OutOfMemoryError。  </p></li><li><p>Java堆<br> 对于大多数应用，<em>Java堆（Java heap）</em>是Java虚拟机所管理内存中最大的一块。Java堆在虚拟机启动时创建，是被所有线程<em>共享</em>的一块内存区域。此内存区域唯一目的是<strong>存放内存对象实例</strong>。<br> Java堆是<strong>垃圾收集器</strong>管理的主要区域，很多时候被称为<strong>GC堆</strong>，即 <strong>Garbage Collected Heap</strong>。<br> Java堆的细分：从内存回收角度，由于现在的收集器基本采用<strong>分代收集算法</strong>，所以Java堆中还可以细分为新生代和老年代。<br> 从内存分配角度，被线程所共享的Java堆中还可以分出多个线程私有的<em>分配缓冲区</em>。不过划分与存放内容无关，划分的目的是为了更好的回收内存，或者更快地分配内存。<br> Java堆可以处于物理上不限续的内存空间中，只要逻辑上连续即可。大多数实现为大小可扩展的，如果在堆中没有完成实例分配且堆也无法扩展时，将抛出<em>OutOfMemoryError</em>异常。  </p></li><li><p>方法区<br> 和Java堆一样，方法区<em>Method Area</em>和Java堆一样是各个线程<em>共享</em>的内存区域，用于存储已经被虚拟机加载过的类信息、常量、静态变量即时编译后的代码等数据。别名“非堆<em>Non- Heap</em>”，目的是和Java堆区分。当方法区内存不够用时，抛出OutOfMemoryError异常。  </p><ol start="6"><li>运行时常量池<br>运行时常量池（<em>Runtime Constant Pool</em>）是方法区的一部分。class文件有一项信息是<em>常量池</em>，用于存放编译期生成的各种字面量和符号引用，在类加载后，这部分内容进入方法区的运行时常量池中存放。但运行时常量池相对于class文件常量池的一个明显特征是<strong>具备动态性</strong>，Java不要求常量只能在编译期间产生，也就是说进入运行时常量池中的内容不一定全部要来自于class文件中常量池的预置，运行期间可以有新的常量进入运行时常量池中。这种特性用的比较多的是String类的intern方法。<br>由于是方法区的一部分，运行时常量池自然被方法区限制，在内存不够用时抛出OutOfMemoryError异常。  </li></ol></li><li><p>直接内存<br> 直接内存不属于Java虚拟机规范中定义的内存区域。这部分内存被频繁使用，且可能导致OutOgMemoryError出现。如果服务器管理员在配置虚拟机参数时忽略直接内存，使得整个内存区域总和大于物理内存限制，从而导致动态扩展时发生OutOfMemoryError异常。  </p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统大纲</title>
    <link href="/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E7%BA%B2/"/>
    <url>/2020/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>进程在运行时，可以在自己的地址空间存储一定量的信息。采用这种信息存储方式有三个问题：<br>（1） 这些地址空间所能存储的信息十分有限。<br>（2）信息可能随着进程的终止而丢失。<br>（3）一个进程中的信息不能并发的被多个进程同时访问。<br>解决方法：<br>使信息的存储独立于任何一个进程。<br>那么怎么存储这些信息，解决以上三个问题呢？<br>存储信息可以使用磁盘(magnetic disk)。使信息独立出来被存储。然而还有问题：<br>（1）怎么直接快速找到想要的信息；<br>（2） 怎么防止一个用户访问别的用户的信息（服务器经常遇到的问题）；<br>（3） 怎么知道哪一块是空闲的。<br>要解决磁盘存储带来的问题，我们建立了文件这个抽象。</p><h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h2><h3 id="文件的定义："><a href="#文件的定义：" class="headerlink" title="文件的定义："></a>文件的定义：</h3><p>文件是进程所创建的信息逻辑单元，受操作系统管理。进程可以读取已经存在的文件并且在需要的时候创建新的文件。操作系统中处理文件的部分称为文件系统。</p><h3 id="文件的结构"><a href="#文件的结构" class="headerlink" title="文件的结构"></a>文件的结构</h3><p>文件有三种构造结构：字节序列、记录序列和树。<br>首先，操作系统并不关心文件是什么内容，它只在乎自己管理的字节。文件内容和含义只在用户程序中解释，操作系统只把文件看做字节序列。用户可以向文件中加入任何想要的或特殊的内容，操作系统不会提供任何帮助，但也不构成任何障碍。把文件看做字节，给操作系统提供了最大的灵活性。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型，只讨论普通文件。<br>普通文件: 包含用户信息的文件，分为二进制文件和ASCII文件。<br>ASCII文件：可以显示和打印，可以用任何编辑器编辑。采用这种文件作为输入输出有利于一个程序的输出作为另外一个的输入。<br>二进制文件：有一定的内部结构，使用该文件的程序才了解此结构。只有文件的格式正确时，操作系统才会执行这个文件。</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>存储介质是磁带时，顺序访问方式是很方便的。<br>不按次序访问文件或目录，这种方法称为随机访问文件。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件的的附加信息称为文件的属性，不同的操作系统文件的属性各不相同。</p><h2 id="二、目录"><a href="#二、目录" class="headerlink" title="二、目录"></a>二、目录</h2><p>文件系统提供目录或者文件夹，用于记录文件的位置。</p><h3 id="（1）一级目录系统"><a href="#（1）一级目录系统" class="headerlink" title="（1）一级目录系统"></a>（1）一级目录系统</h3><p>最简单的形式，一级目录系统在一个目录中包含所有的文件，这个目录称为根目录。</p><h3 id="（2）-层次目录系统"><a href="#（2）-层次目录系统" class="headerlink" title="（2） 层次目录系统"></a>（2） 层次目录系统</h3><p>目录树结构的文件系统</p><h3 id="（3）-路径名"><a href="#（3）-路径名" class="headerlink" title="（3） 路径名"></a>（3） 路径名</h3><p>用层次文件系统指定文件所在位置时，常用两种指定方法：绝对路径名和相对路径名。<br>绝对路径名：从根目录到文件的路径。<br>特点：一定从很目录开始，并且唯一。以三种操作系统为例：<br>Windows  \usr\ast\mailbox<br>UNIX     usr/ast/mailbox<br>MULYICS     &gt;usr&gt;ast&gt;mailbox<br>相对路径名：和当前工作目录一起使用。当前工作目录可以由用户指定。<br>所有的不从根目录开始的路径名都是相对路径名。相对路径往往更加方便，功能也和绝对路径完全相同。<br>那么如何选择路径名呢？<br>如果要访问某一个特定的文件而不考虑当前用户的目录，应采用绝对路径。反之可以选择相对路径。无论用户处在哪个目录下，绝对路径总是能很好的工作。<br>特殊的目录项：”.” 和”..” . 指当前目录， .. 指的是父目录（根目录中指向他自己）。</p><h2 id="三、文件系统的实现"><a href="#三、文件系统的实现" class="headerlink" title="三、文件系统的实现"></a>三、文件系统的实现</h2><p>我们关心文件和目录是怎么样存储、磁盘空间怎么样管理的，以及怎么保证系统有效持续工作。下面解决这些问题。</p><h3 id="1-文件系统布局"><a href="#1-文件系统布局" class="headerlink" title="1.文件系统布局"></a>1.文件系统布局</h3><p>文件系统存放在磁盘上。多数的磁盘被划分为一个或多个分区，每一个分区中有一个独立的文件系统。磁盘中的0号扇区被称为主引导记录(Master Boot Record , MBR)用于引导计算机。MBR的结尾是分区表。给出了每一个分区的开始和结束地址。分区表中有一个分区被标记为活动分区。计算机被引导时，BIOS读入并执行MBR。MBR首先确定这个活动分区并读入它的第一个块——引导块，并执行。引导块中的程序将装载该分区的操作系统。统一起见，每个分区都从一个引导块开始，即使这个块没有可启动的操作系统。<br>除了从引导块开始这个统一的特点，磁盘分区布局随着文件系统的不同而变化，但通常含有下列的项目：超级块、空闲的信息、i节点、根目录</p><h3 id="2-文件系统的实现"><a href="#2-文件系统的实现" class="headerlink" title="2.文件系统的实现"></a>2.文件系统的实现</h3><p>实现的关键问题：记录各个文件分别用到哪个磁盘块。</p><h4 id="（1）连续分配"><a href="#（1）连续分配" class="headerlink" title="（1）连续分配"></a>（1）连续分配</h4><p>把文件作为一系列的连续数据存在磁盘上。例如在块大小为1KB的磁盘上，50KB的文件要分配50个连续的块。注意每个文件都从一个新块开始，也就是说如果有一个文件占据了2.5块的空间那么将有0.5块空间被浪费。<br>连续分配的优势：<br>· 实现简单：只需要记住两个信息即可——第一块的磁盘地址和文件的块数。<br>· 读操作性能好。只需寻找第一个块就可以实现方便的读操作。<br><strong>缺点：</strong><br>长时间使用磁盘空间会变得零碎。首先，我们知道有些文件占用不完一整个磁盘块，但文件的存储都是从完整的块开始的；另外如果有文件被删除，那么会留下一大块空闲块<br>；用户向这个块中存储信息，那么信息的大小会被限制——不能超出这个空闲块的大小；如果存储可变的信息，我们不能要求用户提前告知信息的大小；反之如果信息量较小，那么仍然会存在未利用空闲区。尽管可以压缩磁盘，但是涉及到几乎所有文件的复制和再存储，成本代价高昂。</p><h4 id="（2）链表分配"><a href="#（2）链表分配" class="headerlink" title="（2）链表分配"></a>（2）链表分配</h4><p>为每个文件构造磁盘块链表，每个块的第一个字作为指向下一个块的指针，块的其他部分则用来存放数据。<br><strong>优点：</strong><br>（1）充分利用每一个磁盘块，不会出现连续存储的问题——有过多磁盘碎片而浪费空间（除了最后一块的内部碎片）<br>（2） 顺序访问非常方便。<br><strong>缺点：</strong><br>（1）随机访问十分缓慢。<br>（2） 由于指针占有一定的字节，每一个磁盘块存储数据的字节数不再是2的整数次幂。</p><h4 id="（3）采用内存中的表进行链表分配"><a href="#（3）采用内存中的表进行链表分配" class="headerlink" title="（3）采用内存中的表进行链表分配"></a>（3）采用内存中的表进行链表分配</h4><p>上述链表的两个不足都可以通过这个方式解决：取出每个磁盘块的指针字，把他们一同存放到内存的某个表中。内存中这样的一个表格叫做文件分配表（FAT）。<br>由于整个链表都存放在内存中，所以不需要任何磁盘引用。<br>缺点：必须把整个表都存放在内存中。</p><h4 id="（4）i-节点"><a href="#（4）i-节点" class="headerlink" title="（4）i 节点"></a>（4）i 节点</h4><p>i节点中列出了文件属性和文件块的磁盘地址，是另外一种记录各个文件分别包含哪些磁盘块的方法。<br>优势：给定i节点就能找到文件的所有块。只有对应的文件打开时，他的i 节点才在内存中。相比其他的记录方法，节约了一定的内存空间。</p><h3 id="3-目录的实现"><a href="#3-目录的实现" class="headerlink" title="3.目录的实现"></a>3.目录的实现</h3><p>目录系统的主要功能是把ASCII文件名映射成定位文件数据所需的信息。<br>文件属性可以存放在目录中，也可以存放在i节点中。相比之下第二种方法更好。<br>可变长度的文件名怎么实现？<br>几乎所有的现代操作系统都支持可变长度的文件名。处理有三种方法：<br>· 直接给文件名一个长度限制为每个文件名保留固定大小的空间。<br>· 改变目录项的大小<br>· 目录项长度固定，将文件名放在目录后面的堆中。<br>如何快速查找文件？<br>除了从前到后线性地搜索文件，加快文件搜索速度的一个方法是在每个目录中使用散列表：添加一个文件时，与散列值对应的散列表表项进行检查。如果该表项未被使用，就将一个指向文件目录项的指针放入，文件目录项紧跟散列表之后。反之，构造一个链表表头存放在该表项中，并且连接所有的相同的散列值的文件目录项。</p><h3 id="4-共享文件"><a href="#4-共享文件" class="headerlink" title="4.共享文件"></a>4.共享文件</h3><p>拥有共享文件的系统文件系统A和B，如果A中的一个文件也出现在B的目录下，那么B的目录和该共享文件的联系称为一个链接。这样文件系统本身是一个有向无环图。</p><h3 id="5-日志结构文件系统-Log-structured-File-System-LFS"><a href="#5-日志结构文件系统-Log-structured-File-System-LFS" class="headerlink" title="5.日志结构文件系统( Log-structured File System, LFS )"></a>5.日志结构文件系统( Log-structured File System, LFS )</h3><p>CPU运行速度越来越快，磁盘空间越来越大，磁盘的高速缓存也在不断增加，但是磁盘的寻道时间没有得到快速发展。大多数文件系统中，写操作都是零碎的。这也意味着增加更多的寻道时间，磁盘的利用率降低到1%以下。<br>日志结构文件系统旨在解决这样的问题：即使面对一个很多的零碎的写操作组成的任务，CPU同样能够充分利用磁盘的带宽。其基本思想是将整个磁盘结构化为一个日志：<br>每隔一段时间，被缓冲在内存中的未决定的写操作，都被放到一个单独的段中，作为在日志末尾的一个邻接段写入磁盘。同时，为了找到i节点，LFS利用维护一张由i节点编号索引组成的i节点图来索引文件。<br>为了检查哪些旧的磁盘块仍然占用着先前段的空间，LFS提出了清理线程。周期性的扫描日志并进行压缩：先读取日志中第一个段的摘要，检查有哪些i 节点和文件；然后清理线程查看当前i节点图，判断节点是否有效，文件是否仍然在使用中；如果没有使用，该信息被丢弃。</p><h3 id="6-日志文件系统"><a href="#6-日志文件系统" class="headerlink" title="6.日志文件系统"></a>6.日志文件系统</h3><p>相比于日志结构的文件系统，日志文件系统的出彩之处在于保存了日志结构文件系统的一个重要思想——保存一个用于记录系统下一步要做什么的日志。假设系统正在完成一个任务时出现了崩溃。那么在重启系统后可以通过查看日志获取崩溃前计划要完成的任务，并继续完成他们。相比于日志结构的文件系统，这种日志文件系统得到了广泛的应用。<br>在移除文件操作中，要进行三个操作：<br>（1）目录中删除文件；<br>（2） 释放i节点到空闲i节点池；<br>（3） 归还磁盘块到空闲磁盘块池。<br>日志文件系统先写一个日志项，列出这三个将要完成的动作；然后这个日志项被写入磁盘；只有日志项写入完毕了，其他的操作才可以进行。所有操作成功后擦除日志项。如果发生崩溃系统可以检查日志项，看看是否有操作未完成，从而完成未完成的工作。<br>被写入日志的操作必须是幂等的。</p><h3 id="7-虚拟文件系统"><a href="#7-虚拟文件系统" class="headerlink" title="7.虚拟文件系统"></a>7.虚拟文件系统</h3><p>Virtual File System 虚拟文件系统关键思想是：抽象出所有文件系统的共有部分，并且将这些代码放在共同的一层；该层调用底层的实际文件系统来具体管理数据。<br>VFS对上层用户提供了调用接口，即POSIX接口；VFS也有一个对于实际文件系统的下层接口，VFS接口，这个接口包含许多功能调用。当创造一个新的文件系统协同VFS工作时，新文件系统的设计者就必须明确要确定他提供的VFS需要的系统调用。<br>当系统启动时，根文件系统在VFS中注册。装载其他文件系统时，也必须在VFS中注册。注册时的操作是提供一个包含VFS所需要的函数地址的列表，每个VFS对象一个。因此只要文件在VFS注册了，VFS就知道怎样从它那读取一个块．</p><h2 id="四、文件系统的管理和优化"><a href="#四、文件系统的管理和优化" class="headerlink" title="四、文件系统的管理和优化"></a>四、文件系统的管理和优化</h2><h3 id="1-磁盘空间管理"><a href="#1-磁盘空间管理" class="headerlink" title="1.磁盘空间管理"></a>1.磁盘空间管理</h3><p>文件通常存放在磁盘上。几乎所有的文件系统都把文件分割成固定大小的块来存储。</p><h4 id="（1）块大小"><a href="#（1）块大小" class="headerlink" title="（1）块大小"></a>（1）块大小</h4><p>文件按照块存储，那么块的大小应该是多少？<br>块大小的选择实际上存在悖论。考虑两个因素：数据率和空间利用率。如果优先选择大的块，那么每一次寻道将能够访问更多的数据，将会有更高的数据率，但是对于小文件，由于只能按照分块存储，总会有一定的空间被浪费；反之如果选择较小的块，空间利用率则会大大提高，但是随之而来的是更多的寻道次数和辗转延迟时间。<br>处理方法：随着目前磁盘的容量超过了TB，我们选择较大的磁盘块，接受空间的浪费提高数据率，因为磁盘空间几乎不会再短缺了。</p><h4 id="（2）记录空闲快"><a href="#（2）记录空闲快" class="headerlink" title="（2）记录空闲快"></a>（2）记录空闲快</h4><h5 id="磁盘块链表"><a href="#磁盘块链表" class="headerlink" title="磁盘块链表"></a>磁盘块链表</h5><p>用块记录空闲磁盘块号。1KB的磁盘块可以存放256个32位磁盘块号—————1KB = 1024B = 8192bit = 256 * 32bit<br>这种方法在内存中保存一个指针块。创建一个文件时，需要的指针从中取出。当现有的指针不够用时，从磁盘中读一个新的指针块。删除文件类似、当指针块几乎为空时，一系列短期的临时文件会引起大量的磁盘I/O。</p><h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><p>windows FAT文件系统采用位图来记录空闲块。n个块的磁盘，需要n位位图。在位图中，空闲快用1表示，已分配的用0表示。因为每一个块只用一个二进制位表示，而链表方法中要用到一个32位的块。只有在磁盘空间几乎块满时，链表方法的空间才比位图少。</p><h5 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h5><p>多用户操作系统常常采用这种强制性机制。确保用户不超过分配给他们的额度。</p><h4 id="2-文件系统的性能"><a href="#2-文件系统的性能" class="headerlink" title="2.文件系统的性能"></a>2.文件系统的性能</h4><p>访问磁盘比访问内存慢得多。许多文件系统都采用各种优化措施改善性能。</p><h5 id="（1）高速缓存"><a href="#（1）高速缓存" class="headerlink" title="（1）高速缓存"></a>（1）高速缓存</h5><p>最常用的减少磁盘访问次数的技术是高速缓存（block cache）或者缓冲区高速缓存（buffer cache）。<br>管理高速缓存也有不同的算法，常用算法是：检查全部的读请求，看他们需要的快是不是在高速缓存中。如果是，直接从缓存中读取。否则，首先先把这些快读入高速缓存，再复制到需要的地方。之后的对这些块的访问请求，都可以直接通过高速缓存完成。<br>高速缓存也有许多块，通常通过散列操作，快速确定高速缓存中有没有所需要的块。如果高速缓存满了，就需要将原来的某些快调出高速缓存。如果对这些快有过写操作，那么要把他们写入磁盘。这种情况类似于分页。实际上，分页算法也都适用于高速缓存。</p><h5 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h5><p>只适用于顺序存储的文件。需要用到块之前，试图将他提前写入高速缓存，从而提高命中率。比如用户请求文件系统在某个文件中生成一个快K，那么文件系统会在用户没有察觉的情况下检查高速缓存，看看K+1是否在其中。如果不在，会安排一个预读。这样用户在想要用到K+1时，这个块已经在高速缓存中了，或者，已经预读过了。</p><h5 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h5><p>将可能顺序存储的块放在一起，从而减少磁盘臂的移动次数。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Andrew S.Tanenbaum著 陈向群 马洪兵 等译 Modern Operating Systems[M]. 原书第三版，机械工业出版社.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo个人博客的更多基本操作</title>
    <link href="/2020/08/03/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/08/03/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><pre><code>本文章内容浅显偏重基本操作，只为初学者提供相关的参考。</code></pre><h3 id="概要：-博客中插入图片；-git下拷贝；-简单更换博客的主题；-博客页面美观化；"><a href="#概要：-博客中插入图片；-git下拷贝；-简单更换博客的主题；-博客页面美观化；" class="headerlink" title="概要： 博客中插入图片； git下拷贝； 简单更换博客的主题； 博客页面美观化；"></a>概要： 博客中插入图片； git下拷贝； 简单更换博客的主题； 博客页面美观化；</h3><pre><code>另外，还不清楚怎么部署博客到多个平台的同学参考：https://actonxidian99.gitee.io/2020/07/30/如何用hexo搭建简易的个人博客/</code></pre><h2 id="关于如何在博客中插入图片"><a href="#关于如何在博客中插入图片" class="headerlink" title="关于如何在博客中插入图片"></a>关于如何在博客中插入图片</h2><pre><code>1. 本地引用，在本地的 source 目录下创建一个图片文件夹 imags，存放图片，在博文文章中通过以下格式引用：假如我创建的images目录下有名为 testimage 的 jpg 格式照片，那么引用为：![](/images/testimage.jpg)这样的Markdown语法即可插入本地图片到博客。2. 远程服务端引用，支持引用</code></pre><h2 id="如何在git下复制文件"><a href="#如何在git下复制文件" class="headerlink" title="如何在git下复制文件"></a>如何在git下复制文件</h2><pre><code>使用命令：cat将电脑本地的文件复制到粘贴板：cat filename &gt; /dev/clipboard粘贴板的内容复制到本地文件（这个本地文件支持txt和doc文件等）：cat /dev/clipboard &gt; filename</code></pre><h2 id="简单地更换博客主题"><a href="#简单地更换博客主题" class="headerlink" title="简单地更换博客主题"></a>简单地更换博客主题</h2><pre><code>更换博客的主题，让你的博客看起来更美观。可以借用hexo提供的模板，在官网hexo.io上可以找到更多模板。以yilia主题为例：网址：github.com/litten/hexo-theme-yilia1. 本地git端下载主题： blog 目录下，git clone https://github.com/litten/hexo-theme-yilia.git themes/yilla 将该网址下的主题复制到本地的themes/yilia目录下。如果和github的链接太慢，可以去下载压缩包，手动解压复制到当前的文件下。当然你需要重命名这个解压文件。2. 进入theme目录下，ls可以看到刚下载的主题。3. 配置到自己的博客：blog目录下再次配置 _config.yml文件：找到Theme，将原来的主题换成yilia.4. 回去blog目录hexo g, hexo s即可在本地端口查看到自己的主题。当然你也可以再立刻 hexo d，和刚才一样。把新的主题格式推到github远端上去。</code></pre><h2 id="博客页面更加美观"><a href="#博客页面更加美观" class="headerlink" title="博客页面更加美观"></a>博客页面更加美观</h2><pre><code>1. 下载你心仪的主题时，注意，在对应的主题说明文件中有相关的详细配置，比如我应用的fluid主题相关的配置文件在：https://hexo.fluid-dev.com/docs/guide/2. 确定主题之后根据相应的详细配置说明文档，更好地布置你博客页面的字体、颜色、图片和链接吧！</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何用hexo搭建简易的个人博客</title>
    <link href="/2020/07/30/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/07/30/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="有关如何用hexo搭建简易个人博客的一些声明"><a href="#有关如何用hexo搭建简易个人博客的一些声明" class="headerlink" title="有关如何用hexo搭建简易个人博客的一些声明"></a>有关如何用hexo搭建简易个人博客的一些声明</h2><p>   本文章的教学范围仅限于搭建简易的个人博客，是参考 codesheep 在B站上的视频<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="codesheep: https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11743305723526974314">[1]</span></a></sup>一步步做出来的，想要深入了解的读者可以去仔细研读。本文章只是对羊哥视频的复盘，仅供仍然存在困难的读者一些参考。作者安装的Windows 64位，和羊哥的Mac版本略有不同。</p><h3 id="概要：搭建hexo博客；-将博客部署到github、码云、coding平台的方法。"><a href="#概要：搭建hexo博客；-将博客部署到github、码云、coding平台的方法。" class="headerlink" title="概要：搭建hexo博客； 将博客部署到github、码云、coding平台的方法。"></a>概要：搭建hexo博客； 将博客部署到github、码云、coding平台的方法。</h3><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol><li><p>安装node.js，下载网址：nodejs.org。</p></li><li><p>Windows需要安装git版本控制工具，bai du git下载就能找到。如果觉得下载太慢或无法打开页面，分享我的百度网盘链接：<a href="https://pan.baidu.com/s/1SnmSX1YhbEf65Sk2TrfEVA">https://pan.baidu.com/s/1SnmSX1YhbEf65Sk2TrfEVA</a> 提取码 dcf8，Windows64位2.27版本的。</p></li><li><p>Windows下载后安装git，在网上搜索安装教程即可，应该是要和node工具在一个目录下，因为在不同目录下的尝试没成功。</p><p>这两部分的安装可参考hexo的官方中文文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></li><li><p>打开git bash。</p></li><li><p>依次输入以下命令</p><p>npm install -g cnpm –rigistry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 先借助cnpm安装<br>cnpm install -g hexo-cli 安装hexo博客框架<br>hexo -v 可以查看当前安装的hexo版本</p><p>mkdir blog 在当前路径建立一个博客目录<br>cd blog/ 进入建立的目录</p><p>hexo init 初始化一个博客，这个过程有时候非常漫长，只要不报错总是好的。</p><p>hexo s 启动博客</p><p>会生成一个本地网址，打开就能看到hexo创建的默认博客。</p></li><li><p>新建一篇文章<br>hexo new “我的第一篇博客”，会生成该文章文件和目录。进入这个目录下，就会看到生成的文件了。之后你可以用vi编辑器写文章内容了，支持Markdown格式。</p></li><li><p>退回到blog目录下，生成编辑文章：hexo g</p></li><li><p>输入 hexo s启动博客，即可看到新添加的博文。</p></li></ol><h2 id="博客的简单布置"><a href="#博客的简单布置" class="headerlink" title="博客的简单布置"></a>博客的简单布置</h2><h3 id="博客配置到github"><a href="#博客配置到github" class="headerlink" title="博客配置到github"></a>博客配置到github</h3><p>   配置博客到github，这样就不必始终在本地端口访问了，可以在生成自己的博客网址了。</p><ol><li><p>登陆github，右上角+号，New repository。</p></li><li><p>命名：自己的昵称.github.io，这个地址会作为博客的网址。</p></li><li><p>命令行，博客的blog路径下输入 cnpm install –save hexo-deployer-git，安装一个插件。</p></li><li><p>安装完成后，ls 打开列表，修改_config.yml文件：vim _config.yml，打开后跳到文件末尾，最后的type: 后面修改如下：</p><p>type: git<br>repo: (这里复制刚才新建的_仓库地址)<br>branch: master</p><p>保存退出.</p><p><img src="/images/configyml.jpg"></p></li><li><p>部署到远端：hexo d ，根据提示输入账号和密码.windows下可能出现错误提示：</p><p><img src="/images/warning.jpg"></p><p> 执行提示中的指令，进行github身份核实：</p><p><img src="/images/word.jpg"></p></li><li><p>刷新github仓库就可以看到更新的内容，此时的仓库名字可以直接在浏览器访问了。</p></li><li><p>无法访问有几种情况：</p><p>（1）用户名和仓库名字不一致，查看自己github的账号名称和创建的库名称是否一致。</p><p>（2）手机端可以打开但是电脑端页面找不到，有可能是网络问题，别人的网络或许可以访问你的博客；或者是本地无法和github通信，后者请参考这篇文章：</p><p><a href="https://www.cnblogs.com/notstandalone/p/12496548.html">https://www.cnblogs.com/notstandalone/p/12496548.html</a></p><p>（3）由于网络问题导致的电脑端无法访问，可以考虑部署博客到国内的平台上。</p></li></ol><h3 id="博客部署到码云"><a href="#博客部署到码云" class="headerlink" title="博客部署到码云"></a>博客部署到码云</h3><p>  国内的部署可以更快地访问。部署到码云的步骤和github基本相同。</p><ol><li><p>注册并且登陆码云。</p></li><li><p>创建一个新的仓库。</p></li><li><p>在码云上添加本地电脑的SSH公钥。</p></li><li><p>配置博客的_config.yml_文件，repo：你的码云仓库网址。</p></li><li><p>如果你的配置文件里已经有github的仓库网址，删除或注释掉它。</p></li><li><p>hexo clean + hexo g + hexo d可以把本地的博客推到码云的仓库里。</p></li><li><p>去到仓库里的“服务“板块，部署打开仓库的pages服务：</p></li></ol><p><img src="/img/posts/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitee.png"></p><p>之后会自动产生访问链接啦！</p><h3 id="博客同时部署到多个平台"><a href="#博客同时部署到多个平台" class="headerlink" title="博客同时部署到多个平台"></a>博客同时部署到多个平台</h3><p>  （1）首先需要在这些平台上都创建相应的仓库；</p><p>  （2）修改 _config.yml_文件，repo配置更改示例如下：</p><p><img src="/img/posts/%E5%A6%82%E4%BD%95%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/repo.png"></p><p>  （3）进入source目录下，创建文件： touch Staticfile，必须是这个文件名。</p><p>  （4）hexo clean + hexo g + hexo d 就可以同时推送到配置的多个平台上。</p><p>  （5）建议尽量部署到国内平台，最后一起推到github上去————因为github推远端时大多时候都要再输入账号密码，这对频繁更新的初学者来说浪费了许多时间。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>   作者后续会进行相应的更新，包括插入图片、超链接、配置更美观的界面等。请关注作者的其他文章。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>codesheep: <a href="https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11743305723526974314">https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=11743305723526974314</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
